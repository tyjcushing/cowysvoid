<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Print Sheet Builder — Cowy’s Void</title>
  <meta name="description" content="Paste a list of cards, pick arts, set print scale/bleed, and generate a print-ready sheet." />

  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <link rel="stylesheet" href="/assets/css/void.css">

  <style>
    .ps-controls{display:flex;flex-wrap:wrap;gap:10px 14px;align-items:center;justify-content:space-between}
    .ps-controls .left,.ps-controls .right{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .control-inline{display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18)}
    .control-inline label{font-size:13px;color:var(--muted);user-select:none;white-space:nowrap}
    .control-inline input[type="number"]{width:84px;padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.22);color:var(--text);outline:none}

    /* ✅ picklist: pure black bg, pure white text */
    .control-inline select{
      padding:8px 10px;border-radius:10px;
      border:1px solid rgba(255,255,255,.18);
      background:#000;color:#fff;outline:none;
    }
    .control-inline select option{background:#000;color:#fff}

    /* ✅ wrap build+print together */
    .btn-group{display:inline-flex;gap:8px;padding:8px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.16)}

    .cards-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(230px,1fr));gap:12px;margin-top:10px}
    .card-tile{display:grid;grid-template-columns:96px 1fr;gap:10px;padding:12px;border-radius:16px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.14);box-shadow:0 10px 24px rgba(0,0,0,.24);overflow:hidden}
    .thumb{width:96px;height:134px;border-radius:14px;overflow:hidden;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.06)}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .tile-title{display:flex;align-items:baseline;justify-content:space-between;gap:10px}
    .tile-title strong{font-size:14px;line-height:1.2}
    .tile-meta{margin-top:4px;font-size:12px;color:var(--muted)}
    .tile-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}

    .mono-pre{white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:12px}

    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.68);display:none;align-items:center;justify-content:center;padding:18px;z-index:9999}
    .modal-backdrop.open{display:flex}
    .modal{width:min(1080px,96vw);max-height:88vh;overflow:auto;border-radius:18px;border:1px solid rgba(255,255,255,.12);background:rgba(10,10,14,.92);box-shadow:0 18px 44px rgba(0,0,0,.55);padding:14px}
    .modal-head{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:6px 6px 12px;border-bottom:1px solid rgba(255,255,255,.10);margin-bottom:12px}
    .modal-head h3{margin:0;font-size:16px}

    .prints-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(170px,1fr));gap:12px}
    .print-tile{border-radius:16px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.16);overflow:hidden;cursor:pointer;transition:transform .08s ease}
    .print-tile:hover{transform:translateY(-1px)}
    .print-tile img{width:100%;height:auto;display:block}
    .print-cap{padding:10px}
    .print-cap .line1{display:flex;justify-content:space-between;gap:8px;align-items:baseline}
    .print-cap .line1 strong{font-size:12px}
    .print-cap .line2{margin-top:4px;font-size:11px;color:var(--muted)}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);font-size:11px;color:var(--text)}
    .badge.good{border-color:rgba(120,255,180,.25)}
  </style>
</head>

<body>
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <div class="app-layer">
    <header id="site-header" aria-label="Primary"></header>

    <main class="container">
      <section class="panel page-panel solid-surface">
        <header class="page">
          <h1>Print Sheet Builder</h1>
          <p class="sub">Paste card names. Load → swap art per card → build a print sheet → print.</p>
        </header>

        <div class="toolbar toolbar-wide" role="region" aria-label="Paste cards">
          <label class="input input-solid solid-input" style="align-items:start">
            <textarea id="cardInput" class="textarea" placeholder="Examples:
Sol Ring
sol ring
Dark Ritual
3x Arcane Signet
1 Command Tower"></textarea>
          </label>
        </div>

        <div class="controls-row">
          <button id="loadBtn" class="btn">Load</button>
          <button id="clearBtn" class="btn ghost solid-ghost-btn" type="button">Clear</button>

          <span id="spinner" class="spinner" hidden>
            <span class="spin-dot" aria-hidden="true"></span>
            <span class="inline-hint">Loading…</span>
          </span>

          <label class="control" title="Logs raw Scryfall response to the console">
            <input id="debug" type="checkbox">
            Debug JSON
          </label>
        </div>

        <div class="inline-hint">
          Case-insensitive matching is enabled: <code>Sol Ring</code> and <code>sol ring</code> resolve to the same card.
        </div>
      </section>

      <section class="panel solid-surface">
        <h2>Print Settings</h2>

        <div class="ps-controls" style="margin-top:10px">
          <div class="left">
            <span class="control-inline">
              <label for="scalePct"><strong>Scale</strong></label>
              <button id="scaleDown" class="btn ghost solid-ghost-btn" type="button">−</button>
              <input id="scalePct" type="number" min="50" max="140" step="1" value="100" />
              <span class="inline-hint">%</span>
              <button id="scaleUp" class="btn ghost solid-ghost-btn" type="button">+</button>
            </span>

            <span class="control-inline">
              <label for="bleed"><strong>Bleed / Gap</strong></label>
              <select id="bleed">
                <option value="0">No gap</option>
                <option value="0.2">0.2mm</option>
                <option value="3">3mm</option>
              </select>
            </span>
          </div>

          <!-- ✅ combined -->
          <div class="right">
            <div class="btn-group" aria-label="Build and print">
              <button id="buildBtn" class="btn" type="button">Build Print Sheet</button>
              <button id="printBtn" class="btn ghost solid-ghost-btn" type="button">Print</button>
            </div>
          </div>
        </div>

        <div id="status" class="mono-pre" style="margin-top:10px; opacity:.9"></div>
      </section>

      <section class="panel solid-surface">
        <h2>Cards</h2>
        <div id="empty" class="empty" hidden>Paste cards and click Load.</div>
        <div id="cards" class="cards-grid"></div>
      </section>

      <section id="printArea" hidden></section>
    </main>
  </div>

  <div id="artModalBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="Choose art">
    <div class="modal solid-surface">
      <div class="modal-head">
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <h3 id="artModalTitle" style="margin:0">Choose Art</h3>
          <span id="artModalPicked" class="badge good" hidden>Selected</span>
        </div>
        <button id="artModalClose" class="btn ghost solid-ghost-btn" type="button">Close</button>
      </div>
      <div id="artModalBody"></div>
    </div>
  </div>

<script>
  // ---------- Helpers ----------
  function esc(s) {
    return (s || '').replace(/[&<>\"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[m]));
  }

  // Keep original input for display, but normalize for lookups.
  // Also trims annotations like "(showcase)" or "[set]" etc.
  function stripNameAnnotations(s = '') {
    s = s.trim();
    const cuts = [s.indexOf('['), s.indexOf('{'), s.indexOf('('), s.indexOf('^^')].filter(i => i >= 0);
    if (!cuts.length) return s;
    return s.slice(0, Math.min(...cuts)).trim();
  }

  // canonical key for case-insensitive matching + whitespace normalization
  function keyName(s='') {
    return stripNameAnnotations(s).toLowerCase().replace(/\s+/g,' ').trim();
  }

  function parseCardLines(text) {
    const lines = (text || '').replace(/\r\n?/g, '\n').split('\n');
    const out = [];
    for (let raw of lines) {
      let line = (raw || '').trim();
      if (!line) continue;
      line = line.replace(/\s*\/\/.*$/,'').replace(/\s*#.*$/,'').trim();
      if (!line) continue;

      let m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
      if (m) {
        const qty = parseInt(m[1], 10);
        const nameRaw = stripNameAnnotations(m[2]);
        out.push({ qty, nameRaw, nameKey: keyName(nameRaw) });
      } else {
        const nameRaw = stripNameAnnotations(line);
        out.push({ qty: 1, nameRaw, nameKey: keyName(nameRaw) });
      }
    }
    return out;
  }

  // ---------- Scryfall ----------
  async function fetchCollectionByNames(namesOriginalCasing) {
    const CHUNK = 70;
    const uniq = [...new Set(namesOriginalCasing.filter(Boolean))];
    const out = new Map(); // keyName(card.name) -> card

    for (let i = 0; i < uniq.length; i += CHUNK) {
      const slice = uniq.slice(i, i + CHUNK);
      const body = { identifiers: slice.map(n => ({ name: n })) };
      const r = await fetch('https://api.scryfall.com/cards/collection', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (!r.ok) {
        console.warn('Scryfall collection error', r.status);
        continue;
      }
      const j = await r.json();
      if (document.getElementById('debug')?.checked) {
        console.log('[DEBUG] /cards/collection JSON:', j);
        console.log('[DEBUG] /cards/collection JSON.stringify:', JSON.stringify(j));
      }
      for (const card of (j.data || [])) {
        out.set(keyName(card.name), card);
      }
    }
    return out;
  }

  async function fetchPrintsForOracle(oracleId) {
    // Prints endpoint may be paginated
    const url = `https://api.scryfall.com/cards/search?order=released&q=oracleid:${encodeURIComponent(oracleId)}&unique=prints`;
    let next = url;
    const all = [];
    while (next) {
      const r = await fetch(next);
      if (!r.ok) break;
      const j = await r.json();
      all.push(...(j.data || []));
      next = j.has_more ? j.next_page : null;
    }
    return all;
  }

  function getFrontImage(card, version = 'normal') {
    if (!card) return null;
    if (card.image_uris?.[version]) return card.image_uris[version];
    if (Array.isArray(card.card_faces) && card.card_faces[0]?.image_uris?.[version]) return card.card_faces[0].image_uris[version];
    if (card.id) return `https://api.scryfall.com/cards/${card.id}?format=image&version=${encodeURIComponent(version)}`;
    return null;
  }

  // ---------- State ----------
  // items are "unique card rows" (one per normalized nameKey), each has qty and selectedPrintId/imageUrl
  let ITEMS = []; // [{ nameKey, displayName, qty, oracleId, selectedPrintId, selectedImg }]
  let KEY_TO_CARD = new Map(); // nameKey -> base card from collection
  const PRINT_CACHE = new Map(); // oracleId -> prints array

  // ---------- Elements ----------
  const els = {
    input: document.getElementById('cardInput'),
    loadBtn: document.getElementById('loadBtn'),
    clearBtn: document.getElementById('clearBtn'),
    spinner: document.getElementById('spinner'),
    empty: document.getElementById('empty'),
    cards: document.getElementById('cards'),
    status: document.getElementById('status'),

    scalePct: document.getElementById('scalePct'),
    scaleDown: document.getElementById('scaleDown'),
    scaleUp: document.getElementById('scaleUp'),
    bleed: document.getElementById('bleed'),

    buildBtn: document.getElementById('buildBtn'),
    printBtn: document.getElementById('printBtn'),
    printArea: document.getElementById('printArea'),

    artBackdrop: document.getElementById('artModalBackdrop'),
    artClose: document.getElementById('artModalClose'),
    artTitle: document.getElementById('artModalTitle'),
    artBody: document.getElementById('artModalBody'),
    artPicked: document.getElementById('artModalPicked')
  };

  function setStatus(msg='') { els.status.textContent = msg; }
  function setBusy(b) { els.spinner.hidden = !b; }
  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  // ---------- UI render ----------
  function renderCards() {
    els.cards.innerHTML = '';

    const total = ITEMS.reduce((s, it) => s + (it.qty || 1), 0);
    setStatus(`Loaded ${ITEMS.length} unique name(s), ${total} total card(s).`);

    for (const it of ITEMS) {
      const img = it.selectedImg || getFrontImage(KEY_TO_CARD.get(it.nameKey), 'normal') || getFrontImage(KEY_TO_CARD.get(it.nameKey), 'large');
      const base = KEY_TO_CARD.get(it.nameKey);
      const setName = (base?.set || '').toUpperCase();
      const cn = base?.collector_number || '—';
      const artist = base?.artist || '—';

      const div = document.createElement('div');
      div.className = 'card-tile';
      div.innerHTML = `
        <div class="thumb">
          ${img ? `<img src="${img}" alt="${esc(it.displayName)}" loading="lazy" referrerpolicy="no-referrer" crossorigin="anonymous">` : ''}
        </div>
        <div>
          <div class="tile-title">
            <strong>${esc(it.displayName)}</strong>
            <span class="pill">× <strong>${it.qty || 1}</strong></span>
          </div>
          <div class="tile-meta">${esc(setName)} · #${esc(cn)} · ${esc(artist)}</div>
          <div class="tile-actions">
            <button class="btn ghost solid-ghost-btn" type="button"
              data-action="art"
              data-key="${esc(it.nameKey)}">Change Art</button>
          </div>
          <div class="inline-hint" style="margin-top:8px; opacity:.9">
            ${it.selectedPrintId ? `Selected print: <code>${esc(it.selectedPrintId)}</code>` : `Using default print.`}
          </div>
        </div>
      `;
      els.cards.appendChild(div);
    }
  }

  // ---------- Load flow ----------
  function collapseToUniqueItems(parsedItems) {
    const byKey = new Map();
    for (const row of parsedItems) {
      const k = row.nameKey;
      const prev = byKey.get(k);
      if (!prev) {
        byKey.set(k, { nameKey:k, displayName: row.nameRaw, qty: row.qty || 1 });
      } else {
        prev.qty += (row.qty || 1);
        // keep first display name as typed
      }
    }
    return [...byKey.values()];
  }

  async function load() {
    setBusy(true);
    try {
      const parsed = parseCardLines(els.input.value);
      els.empty.hidden = parsed.length > 0;

      if (!parsed.length) {
        ITEMS = [];
        KEY_TO_CARD = new Map();
        els.cards.innerHTML = '';
        setStatus('Paste cards and click Load.');
        return;
      }

      const uniqItems = collapseToUniqueItems(parsed);

      // For collection identifiers, use the *displayName* (original) so Scryfall has best chance of matching.
      const namesForScryfall = uniqItems.map(it => it.displayName);
      const mapKeyToCard = await fetchCollectionByNames(namesForScryfall);

      KEY_TO_CARD = mapKeyToCard;

      // Build ITEMS with oracleId + default selected art
      const missing = [];
      ITEMS = uniqItems.map(it => {
        const base = mapKeyToCard.get(it.nameKey);
        if (!base) missing.push(it.displayName);
        return {
          ...it,
          oracleId: base?.oracle_id || null,
          selectedPrintId: null,
          selectedImg: null
        };
      });

      renderCards();

      if (missing.length) {
        setStatus(
          `Loaded ${uniqItems.length - missing.length}/${uniqItems.length} unique name(s).\nMissing:\n- ` +
          missing.slice(0, 20).join('\n- ') +
          (missing.length > 20 ? `\n…and ${missing.length - 20} more` : '')
        );
      }
    } catch (e) {
      console.error(e);
      setStatus(String(e?.message || e));
    } finally {
      setBusy(false);
    }
  }

  // ---------- Art swap modal ----------
  let MODAL_KEY = null;

  function openArtModalFor(nameKey) {
    MODAL_KEY = nameKey;
    const item = ITEMS.find(x => x.nameKey === nameKey);
    const base = KEY_TO_CARD.get(nameKey);

    if (!item || !base?.oracle_id) return;

    els.artTitle.textContent = `Choose Art — ${item.displayName}`;
    els.artPicked.hidden = true;
    els.artBody.innerHTML = `<div class="inline-hint">Loading prints…</div>`;
    els.artBackdrop.classList.add('open');

    loadPrintsIntoModal(base.oracle_id, item.selectedPrintId);
  }

  async function loadPrintsIntoModal(oracleId, selectedPrintId) {
    try {
      let prints = PRINT_CACHE.get(oracleId);
      if (!prints) {
        prints = await fetchPrintsForOracle(oracleId);
        PRINT_CACHE.set(oracleId, prints);
      }

      // Filter to things that actually have front images
      const good = prints
        .map(p => ({
          id: p.id,
          set: (p.set || '').toUpperCase(),
          cn: p.collector_number || '—',
          artist: p.artist || '—',
          released: p.released_at || '—',
          img: getFrontImage(p, 'small') || getFrontImage(p, 'normal') || getFrontImage(p, 'large')
        }))
        .filter(p => !!p.img);

      if (!good.length) {
        els.artBody.innerHTML = `<div class="inline-hint">No printable images found for this card.</div>`;
        return;
      }

      els.artBody.innerHTML = `
        <div class="inline-hint" style="margin-bottom:10px">
          Click a print to select its art. (${good.length} found)
        </div>
        <div class="prints-grid">
          ${good.map(p => `
            <div class="print-tile" data-print-id="${esc(p.id)}" data-img="${esc(p.img)}">
              <img src="${esc(p.img)}" alt="${esc(p.set)} ${esc(p.cn)}" loading="lazy" referrerpolicy="no-referrer" crossorigin="anonymous">
              <div class="print-cap">
                <div class="line1">
                  <strong>${esc(p.set)}</strong>
                  <span class="badge ${p.id === selectedPrintId ? 'good' : ''}">${p.id === selectedPrintId ? 'Selected' : `#${esc(p.cn)}`}</span>
                </div>
                <div class="line2">${esc(p.released)} · ${esc(p.artist)}</div>
              </div>
            </div>
          `).join('')}
        </div>
      `;
    } catch (e) {
      console.error(e);
      els.artBody.innerHTML = `<div class="inline-hint">Failed to load prints: ${esc(e?.message || String(e))}</div>`;
    }
  }

  function closeArtModal() {
    els.artBackdrop.classList.remove('open');
    MODAL_KEY = null;
  }

  function applySelectedPrintToItem(nameKey, printId, imgUrl) {
    const idx = ITEMS.findIndex(x => x.nameKey === nameKey);
    if (idx < 0) return;

    ITEMS[idx].selectedPrintId = printId;
    // store a normal-ish image for the tile display; "small" is fine too but normal looks nicer
    // we only have whatever was in the modal; that might be small. We'll ask scryfall for a better one:
    ITEMS[idx].selectedImg = imgUrl;

    // Update badge feedback in modal
    els.artPicked.hidden = false;
    els.artPicked.textContent = 'Selected';

    renderCards();
  }

  // ---------- Print sheet (stub for now, stays functional)
  function buildPrintSheet() {
    if (!ITEMS.length) { setStatus('Load cards first.'); return; }

    const scale = Number(els.scalePct.value || 100) / 100;
    const gapMm = Number(els.bleed.value || 0);

    setStatus(
      `Print settings:\n- Scale: ${(scale * 100).toFixed(0)}%\n- Gap/Bleed: ${gapMm}mm\n\nNext: render print grid (work-in-progress).`
    );

    els.printArea.hidden = true;
    els.printArea.innerHTML = '';
  }

  function doPrint() {
    if (!els.printArea.innerHTML.trim()) {
      setStatus('Build the print sheet first. (Print grid output is not rendered yet.)');
      return;
    }
    window.print();
  }

  // ---------- Events ----------
  document.addEventListener('DOMContentLoaded', () => {
    els.loadBtn.addEventListener('click', load);

    els.clearBtn.addEventListener('click', () => {
      els.input.value = '';
      els.cards.innerHTML = '';
      els.empty.hidden = false;
      setStatus('');
      ITEMS = [];
      KEY_TO_CARD = new Map();
      PRINT_CACHE.clear();
    });

    els.scaleDown.addEventListener('click', () => {
      els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) - 1, 50, 140));
    });
    els.scaleUp.addEventListener('click', () => {
      els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) + 1, 50, 140));
    });
    els.scalePct.addEventListener('change', () => {
      els.scalePct.value = String(clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140));
    });

    els.buildBtn.addEventListener('click', buildPrintSheet);
    els.printBtn.addEventListener('click', doPrint);

    els.cards.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action="art"]');
      if (!btn) return;
      const k = btn.getAttribute('data-key');
      openArtModalFor(k);
    });

    els.artClose.addEventListener('click', closeArtModal);
    els.artBackdrop.addEventListener('click', (e) => { if (e.target === els.artBackdrop) closeArtModal(); });

    // Click a print tile -> select
    els.artBody.addEventListener('click', (e) => {
      const tile = e.target.closest('.print-tile');
      if (!tile || !MODAL_KEY) return;
      const pid = tile.getAttribute('data-print-id');
      const img = tile.getAttribute('data-img');
      applySelectedPrintToItem(MODAL_KEY, pid, img);
    });
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
    const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
    const allowVideo = isFast && isWifiLike;

    const wrap = document.getElementById('bgVideo');
    const vid  = document.getElementById('bgVideoEl');
    if (!wrap || !vid) return;

    if (!allowVideo) { wrap.style.display = 'none'; return; }

    vid.src = '/assets/Blackhole_Animtation.mp4';

    const onReady = () => {
      wrap.classList.add('ready');
      const p = vid.play();
      if (p && typeof p.catch === 'function') p.catch(() => {});
    };

    vid.addEventListener('canplay', onReady, { once: true });
    vid.addEventListener('loadeddata', onReady, { once: true });
    vid.addEventListener('loadedmetadata', () => wrap.classList.add('ready'), { once: true });
  });
</script>

<script>
  (async () => {
    try {
      async function loadPartial(url) {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        const html = await res.text();
        const tpl = document.createElement('template');
        tpl.innerHTML = html.trim();
        tpl.content.querySelectorAll('style').forEach(st => {
          document.head.appendChild(st.cloneNode(true));
          st.remove();
        });
        return tpl.content.firstElementChild || null;
      }

      const header = document.getElementById('site-header');
      const navEl = await loadPartial('/partials/nav.html');
      if (header && navEl) {
        header.innerHTML = '';
        header.appendChild(navEl);
        initNav(header);
      }

      const discordEl = await loadPartial('/partials/discord.html');
      if (discordEl) document.body.appendChild(discordEl);

      const footerEl = await loadPartial('/partials/footer.html');
      if (footerEl) document.body.appendChild(footerEl);

      function initNav(scope) {
        const btn = scope.querySelector('.menu-toggle');
        const panel = scope.querySelector('#nav-panel');
        if (btn && panel) {
          btn.addEventListener('click', () => {
            const open = panel.classList.toggle('open');
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
          });
        }
        const here = location.pathname.toLowerCase().replace(/\/+$/, '');
        scope.querySelectorAll('.nav-link').forEach(a => {
          let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
          if (href === '/blog/') href = '/blog';
          if (here === href || ((here === '' || here === '/') && href === '/index.html')) {
            a.setAttribute('aria-current', 'page');
          }
          if (here.includes('/projects')) a.setAttribute('aria-current', 'page');
          if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
        });
      }
    } catch (e) {
      console.warn('Partial load failed:', e);
    }
  })();
</script>
</body>
</html>
