<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Print Sheet Builder — Cowy’s Void</title>
  <meta name="description" content="Paste a list of Magic cards, select specific prints, and generate a print-ready PDF." />
  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <link rel="stylesheet" href="/assets/css/void.css">
  <style>
    .controls-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .control { display:flex; gap:8px; align-items:center; }
    .control select, .control input[type="number"] { min-height: 38px; }
    .pill-lite { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .status-box { margin-top:10px; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: .95; }
    .cards-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 12px; margin-top:12px; }
    .card-tile { display:flex; flex-direction:column; gap:10px; padding: 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.12); background: rgba(10,10,16,.55); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .card-top { display:flex; gap:10px; align-items:flex-start; }
    .card-meta { flex: 1; min-width: 0; }
    .card-meta .name { font-weight: 700; line-height:1.15; }
    .card-meta .sub { color: var(--muted); font-size: 12px; margin-top: 4px; }
    .qty-badge { align-self:flex-start; padding: 4px 10px; border-radius: 999px; font-weight: 700; background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.14); }
    .img-wrap { display:flex; justify-content:center; }
    .img-wrap img { width: 100%; max-width: 320px; height: auto; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.25); }
    .tile-actions { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .mini { font-size: 12px; color: var(--muted); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }

    select.pick-black {
      background: #000 !important;
      color: #fff !important;
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 12px;
      padding: 8px 10px;
      min-height: 40px;
    }
    select.pick-black option { background:#000; color:#fff; }

    /* Modal */
    .modal-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      width: min(980px, 96vw);
      max-height: min(90vh, 900px);
      overflow: hidden;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,10,16,.92);
      box-shadow: 0 30px 80px rgba(0,0,0,.6);
      display:flex;
      flex-direction:column;
    }
    .modal-header {
      position: sticky;
      top: 0;
      z-index: 2;
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(10,10,16,.96);
    }
    .modal-title { font-weight: 800; }
    .modal-body { padding: 12px 14px 14px; overflow:auto; }
    .prints-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .print-tile {
      border-radius: 12px;
      border: 2px solid transparent;
      background: rgba(255,255,255,.04);
      padding: 8px;
      cursor: pointer;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      user-select: none;
    }
    .print-tile:hover { transform: translateY(-1px); background: rgba(255,255,255,.06); }
    .print-tile.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset; }
    .print-tile img { width: 100%; height: auto; border-radius: 10px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.25); display:block; }
    .print-cap { margin-top: 6px; font-size: 11px; color: var(--muted); line-height: 1.2; }

    /* ---------------- PRINT SHEET ---------------- */
    #printRoot { display:none; }

    @media print {
      /* Hide the app UI */
      body { background: #fff !important; }
      .bg-video, .app-layer { display:none !important; }

      /* Show print root */
      #printRoot { display:block !important; }

      /* Remove any default margins */
      @page { margin: 0; }
    }

    /* These vars get set in JS right before printing */
    #printRoot {
      --page-w-mm: 215.9;
      --page-h-mm: 279.4;
      --cols: 3;
      --rows: 3;
      --gap-mm: 3;
      --card-w-mm: 63;
      --card-h-mm: 88;
    }

    .print-page {
      width: calc(var(--page-w-mm) * 1mm);
      height: calc(var(--page-h-mm) * 1mm);
      page-break-after: always;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .print-grid {
      display:grid;
      grid-template-columns: repeat(var(--cols), calc(var(--card-w-mm) * 1mm));
      grid-template-rows: repeat(var(--rows), calc(var(--card-h-mm) * 1mm));
      gap: calc(var(--gap-mm) * 1mm);
      align-content:center;
      justify-content:center;
    }
    .print-cell {
      width: calc(var(--card-w-mm) * 1mm);
      height: calc(var(--card-h-mm) * 1mm);
      overflow:hidden;
      background:#fff;
    }
    .print-cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display:block;
    }
  </style>
</head>

<body>
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <div class="app-layer">
    <header id="site-header" aria-label="Primary"></header>

    <main class="container">
      <section class="panel page-panel solid-surface">
        <header class="page">
          <h1>Print Sheet Builder</h1>
          <p class="sub">Paste cards, choose specific art, then generate a print-ready PDF.</p>
        </header>

        <div class="toolbar toolbar-wide" role="region" aria-label="Paste cards">
          <label class="input input-solid solid-input" style="align-items:start">
            <textarea id="deckInput" class="textarea" placeholder="Examples:
Fowl Strike
1 Sol Ring
3x Dark Ritual
1 Arcane Signet (SLD) 1492
Commander: Alela, Artful Provocateur

(Quantities supported; comments with # or // ignored)"></textarea>
          </label>
        </div>

        <div class="controls-row">
          <button id="loadBtn" class="btn">Load Cards</button>
          <button id="clearBtn" class="btn ghost solid-ghost-btn" type="button">Clear</button>

          <span id="spinner" class="spinner" hidden>
            <span class="spin-dot" aria-hidden="true"></span>
            <span class="inline-hint">Loading…</span>
          </span>

          <span class="">
            <strong>Scale</strong>
            <span class="control" style="display:inline-flex; gap:6px; margin-left:8px;">
              <button id="scaleDown" class="btn ghost solid-ghost-btn" type="button" aria-label="Decrease scale">−</button>
              <input id="scalePct" type="number" min="50" max="140" step="1" value="101"
                     style="width:84px; text-align:center; border-radius:12px;"
                     aria-label="Scale percent">
              <button id="scaleUp" class="btn ghost solid-ghost-btn" type="button" aria-label="Increase scale">+</button>
            </span>
          </span>

          <span class="control" title="Gap / bleed between cards on the PDF sheet">
            <label for="gapMm"><strong>Gap</strong></label>
            <select id="gapMm" class="pick-black" aria-label="Gap setting">
              <option value="0">0mm</option>
              <option value="0.2">0.2mm</option>
              <option value="3" selected>3mm</option>
            </select>
          </span>

          <span class="control">
            <label for="layout"><strong>Layout</strong></label>
            <select id="layout" class="pick-black" aria-label="Print layout">
              <option value="LETTER_3x3" selected>US Letter (8.5×11) · 3×3 </option>
              <option value="LETTER_3x4">US Letter (8.5×11) · 3×4</option>
              <option value="A4_3x3">A4 · 3×3</option>
              <option value="A4_3x4">A4 · 3×4</option>
            </select>
          </span>

            <button id="printBtn" class="btn">Print</button>

        </div>

        <!--  Under line printing hint goes here.
        <div class="inline-hint" style="margin-top:8px">
        </div>-->

        <div id="status" class="status-box"></div>
      </section>

      <section class="panel solid-surface">
        <h2>Cards</h2>
        <div id="empty" class="empty">Paste cards and click Load Cards.</div>
        <div id="cards" class="cards-grid"></div>
      </section>
    </main>
  </div>

  <!-- PRINT ROOT (hidden until printing) -->
  <div id="printRoot" aria-hidden="true"></div>

  <!-- Art Modal -->
  <div id="artBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="Choose alternate art">
    <div class="modal">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="artTitle">Choose Art</div>
          <div class="inline-hint" id="artSub" style="margin-top:4px">Click an image to select.</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="artClose" class="btn ghost solid-ghost-btn" type="button">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div id="artBody" class="prints-grid"></div>
      </div>
    </div>
  </div>

<script>
  const SCRY_COLLECTION = 'https://api.scryfall.com/cards/collection';
  const SCRY_SEARCH_PRINTS = (oracleId) =>
    `https://api.scryfall.com/cards/search?order=released&q=oracleid%3A${encodeURIComponent(oracleId)}&unique=prints`;

  const UI_IMG = (card) => card?.image_uris?.normal || card?.card_faces?.[0]?.image_uris?.normal || '';
  const PRINT_IMG = (card) =>
    card?.image_uris?.large || card?.image_uris?.normal ||
    card?.card_faces?.[0]?.image_uris?.large || card?.card_faces?.[0]?.image_uris?.normal || '';

  const els = {
    input: document.getElementById('deckInput'),
    loadBtn: document.getElementById('loadBtn'),
    clearBtn: document.getElementById('clearBtn'),
    spinner: document.getElementById('spinner'),
    cards: document.getElementById('cards'),
    empty: document.getElementById('empty'),
    status: document.getElementById('status'),

    scaleDown: document.getElementById('scaleDown'),
    scaleUp: document.getElementById('scaleUp'),
    scalePct: document.getElementById('scalePct'),
    gapMm: document.getElementById('gapMm'),
    layout: document.getElementById('layout'),
    printBtn: document.getElementById('printBtn'),

    artBackdrop: document.getElementById('artBackdrop'),
    artTitle: document.getElementById('artTitle'),
    artSub: document.getElementById('artSub'),
    artBody: document.getElementById('artBody'),
    artClose: document.getElementById('artClose'),

    printRoot: document.getElementById('printRoot'),
  };

  function esc(v) {
    const s = (v == null) ? '' : String(v);
    return s.replace(/[&<>\"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
    }[m]));
  }
  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
  function setStatus(msg) { els.status.textContent = msg || ''; }

  function stripNameAnnotations(s = '') {
    s = String(s || '').trim();
    const cuts = [s.indexOf('['), s.indexOf('{'), s.indexOf('('), s.indexOf('^^')].filter(i => i >= 0);
    if (!cuts.length) return s;
    return s.slice(0, Math.min(...cuts)).trim();
  }

  async function fetchCardBySetAndNumber(setCode, collectorNumber) {
    const set = String(setCode || '').trim().toLowerCase();
    const cn = String(collectorNumber || '').trim();
    if (!set || !cn) return null;

    const url = `https://api.scryfall.com/cards/${encodeURIComponent(set)}/${encodeURIComponent(cn)}`;
    const r = await fetch(url);
    if (!r.ok) return null;
    return await r.json();
  }

  function parseDeckText(text) {
    const lines = (text || '').replace(/\r\n?/g, '\n').split('\n');
    const items = [];
    let section = 'Deck';

    for (let raw of lines) {
      let line = String(raw || '').trim();
      if (!line) continue;

      line = line.replace(/\s*\/\/.*$/,'').replace(/\s*#.*$/,'').trim();
      if (!line) continue;

      if (/^commander:?$/i.test(line))   { section = 'Commander'; continue; }
      if (/^companion:?$/i.test(line))   { section = 'Companion'; continue; }
      if (/^deck:?$/i.test(line))        { section = 'Deck';      continue; }
      if (/^sideboard:?$/i.test(line))   { section = 'Sideboard'; continue; }
      if (/^maybeboard:?$/i.test(line))  { section = 'Maybeboard';continue; }

      let m = line.match(/^commander:\s*(.+)$/i);
      if (m) {
        const parsed = parseLineWithPrintHints(m[1]);
        items.push({ qty: 1, section: 'Commander', ...parsed });
        continue;
      }

      m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
      if (m) {
        const qty = parseInt(m[1], 10);
        const parsed = parseLineWithPrintHints(m[2]);
        items.push({ qty, section, ...parsed });
        continue;
      }

      const parsed = parseLineWithPrintHints(line);
      items.push({ qty: 1, section, ...parsed });
    }

    return items;
  }

  function parseLineWithPrintHints(line) {
    let s = String(line || '').trim();
    s = s.replace(/\s+\*[^*]+\*\s*$/g, '').trim();

    const m = s.match(/^(.*?)(?:\s+\(([A-Za-z0-9]{2,6})\))\s+([0-9]+[A-Za-z]?)\s*$/);
    if (m) {
      const nameRaw = m[1];
      const setCode = m[2];
      const collectorNumber = m[3];
      return {
        name: stripNameAnnotations(nameRaw),
        setCode: setCode,
        collectorNumber: collectorNumber
      };
    }

    return {
      name: stripNameAnnotations(s),
      setCode: null,
      collectorNumber: null
    };
  }

  function countByName(items) {
    const m = new Map();
    for (const it of items) {
      if (!it?.name) continue;
      const k = it.name;
      m.set(k, (m.get(k) || 0) + (it.qty || 1));
    }
    return m;
  }

  let ITEMS = [];
  const ORACLE_TO_CARD = new Map();
  const ORACLE_TO_PRINTS = new Map();
  const PRINT_CACHE = new Map();
  let MODAL_ORACLE = null;

  async function fetchCollectionByNames(names) {
    const CHUNK = 70;
    const uniq = [...new Set(names.filter(Boolean))];
    const out = [];

    for (let i = 0; i < uniq.length; i += CHUNK) {
      const slice = uniq.slice(i, i + CHUNK);
      const body = { identifiers: slice.map(n => ({ name: n })) };

      const r = await fetch(SCRY_COLLECTION, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      if (!r.ok) continue;
      const j = await r.json();
      (j.data || []).forEach(c => out.push(c));
    }
    return out;
  }

  async function fetchPrintsForOracle(oracleId) {
    if (ORACLE_TO_PRINTS.has(oracleId)) return ORACLE_TO_PRINTS.get(oracleId);

    const url = SCRY_SEARCH_PRINTS(oracleId);
    const r = await fetch(url);
    if (!r.ok) {
      ORACLE_TO_PRINTS.set(oracleId, []);
      return [];
    }
    const j = await r.json();
    const prints = (j.data || []);
    ORACLE_TO_PRINTS.set(oracleId, prints);

    for (const p of prints) {
      if (p?.id) PRINT_CACHE.set(p.id, p);
    }
    return prints;
  }

  function formatSelectedSetCollector(card) {
    const setCode = String(card?.set || '').toUpperCase();
    const cn = String(card?.collector_number || '');
    const mid = [setCode, cn].filter(Boolean).join(' ').trim();
    return mid || '—';
  }

  function getEffectiveCardForItem(it) {
    if (!it) return null;
    if (it.chosen_print_id) return PRINT_CACHE.get(it.chosen_print_id) || null;
    return ORACLE_TO_CARD.get(it.oracle_id) || null;
  }

  function syncModalSublineForOracle(oracleId) {
    if (!els.artSub) return;
    const it = ITEMS.find(x => x.oracle_id === oracleId);
    const c = getEffectiveCardForItem(it);
    els.artSub.textContent = `Selected: ${formatSelectedSetCollector(c)}`;
  }

  function renderCards() {
    els.cards.innerHTML = '';
    els.empty.hidden = ITEMS.length > 0;

    els.cards.innerHTML = ITEMS.map(it => {
      const effectiveCard = getEffectiveCardForItem(it);
      const img = it.chosen_img_ui || UI_IMG(effectiveCard) || UI_IMG(ORACLE_TO_CARD.get(it.oracle_id)) || '';
      const subtitleCard = getEffectiveCardForItem(it) || ORACLE_TO_CARD.get(it.oracle_id);
      const subtitle = subtitleCard?.set_name
        ? subtitleCard.set_name
        : (subtitleCard?.set ? String(subtitleCard.set).toUpperCase() : '—');


      const selectedText = formatSelectedSetCollector(effectiveCard);

      return `
        <article class="card-tile" data-oracle="${esc(it.oracle_id)}">
          <div class="card-top">
            <div class="card-meta">
              <div class="name">${esc(it.name)}</div>
              <div class="sub">${esc(subtitle)}</div>
            </div>
            <div class="qty-badge">×${it.qty}</div>
          </div>

          <div class="img-wrap">
            ${img
              ? `<img loading="lazy" src="${esc(img)}" alt="${esc(it.name)}">`
              : `<div class="inline-hint">No image available.</div>`
            }
          </div>

          <div class="tile-actions">
            <div class="mini">Selected: ${esc(selectedText)}</div>
            <div class="btn-row">
              <button class="btn ghost solid-ghost-btn" type="button" data-action="art" data-oracle="${esc(it.oracle_id)}">Swap Art</button>
            </div>
          </div>
        </article>
      `;
    }).join('');
  }

  function openArtModalFor(oracleId) {
    MODAL_ORACLE = oracleId;
    const it = ITEMS.find(x => x.oracle_id === oracleId);
    els.artTitle.textContent = it ? `Choose Art — ${it.name}` : 'Choose Art';
    els.artBody.innerHTML = `<div class="inline-hint">Loading prints…</div>`;
    els.artBackdrop.style.display = 'flex';

    syncModalSublineForOracle(oracleId);

    fetchPrintsForOracle(oracleId).then(prints => {
      const currentPrintId = it?.chosen_print_id || null;

      if (!prints.length) {
        els.artBody.innerHTML = `<div class="inline-hint">No alternate prints found.</div>`;
        return;
      }

      els.artBody.innerHTML = prints.map(p => {
        const ui = UI_IMG(p);
        const set = String(p?.set || '').toUpperCase();
        const cn = p?.collector_number || '';
        const selected = (currentPrintId && p.id === currentPrintId) ? 'selected' : '';
        return `
          <div class="print-tile ${selected}" data-print-id="${esc(p.id)}">
            ${ui ? `<img loading="lazy" src="${esc(ui)}" alt="${esc(p.name)}">` : `<div class="inline-hint">No image</div>`}
            <div class="print-cap">${esc(set)} · ${esc(cn)}</div>
          </div>
        `;
      }).join('');
    }).catch(() => {
      els.artBody.innerHTML = `<div class="inline-hint">Failed to load prints.</div>`;
    });
  }

  function closeArtModal() {
    MODAL_ORACLE = null;
    els.artBackdrop.style.display = 'none';
    els.artBody.innerHTML = '';
  }

  function applySelectedPrint(oracleId, printId) {
    const it = ITEMS.find(x => x.oracle_id === oracleId);
    const p = PRINT_CACHE.get(printId);
    if (!it || !p) return;

    it.chosen_print_id = printId;
    it.chosen_img_ui = UI_IMG(p);
    it.chosen_img_print = PRINT_IMG(p);

    renderCards();
    syncModalSublineForOracle(oracleId);
  }

  function layoutSpec(value) {
    const A4 = { w: 210, h: 297 };
    const LETTER = { w: 215.9, h: 279.4 };
    switch (value) {
      case 'LETTER_3x4': return { page: LETTER, cols: 3, rows: 4 };
      case 'A4_3x3':     return { page: A4, cols: 3, rows: 3 };
      case 'A4_3x4':     return { page: A4, cols: 3, rows: 4 };
      case 'LETTER_3x3':
      default:           return { page: LETTER, cols: 3, rows: 3 };
    }
  }

  function buildExpandedItems() {
    const expanded = [];
    for (const it of ITEMS) {
      for (let i = 0; i < (it.qty || 1); i++) expanded.push(it);
    }
    return expanded;
  }

  function getPrintUrl(it) {
    if (it?.chosen_img_print) return it.chosen_img_print;
    const c = ORACLE_TO_CARD.get(it.oracle_id);
    return PRINT_IMG(c) || '';
  }

  async function waitForPrintImages(root) {
    const imgs = [...root.querySelectorAll('img')];
    const decodePromises = imgs.map(img => {
      if (img.complete && img.naturalWidth > 0) return Promise.resolve();

      if (typeof img.decode === 'function') {
        return img.decode().catch(() => new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = () => reject(new Error('img.onerror'));
        }));
      }

      return new Promise((resolve, reject) => {
        img.onload = () => resolve();
        img.onerror = () => reject(new Error('img.onerror'));
      });
    });

    const results = await Promise.allSettled(decodePromises);
    const failed = results.filter(r => r.status === 'rejected').length;
    return { total: imgs.length, failed };
  }

  function setPrintCssVars(layout, gapMm, scalePct) {
    const scale = clamp(scalePct, 50, 140) / 100;
    const cardWmm = 63 * scale;
    const cardHmm = 88 * scale;

    els.printRoot.style.setProperty('--page-w-mm', String(layout.page.w));
    els.printRoot.style.setProperty('--page-h-mm', String(layout.page.h));
    els.printRoot.style.setProperty('--cols', String(layout.cols));
    els.printRoot.style.setProperty('--rows', String(layout.rows));
    els.printRoot.style.setProperty('--gap-mm', String(gapMm));
    els.printRoot.style.setProperty('--card-w-mm', String(cardWmm));
    els.printRoot.style.setProperty('--card-h-mm', String(cardHmm));
  }

  function buildPrintDom() {
    const layout = layoutSpec(els.layout.value);

    const scalePct = clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140);
    const gapMm = (isFinite(parseFloat(els.gapMm.value)) ? parseFloat(els.gapMm.value) : 3);

    setPrintCssVars(layout, gapMm, scalePct);

    const expanded = buildExpandedItems();
    if (!expanded.length) throw new Error('No cards to print.');

    const perPage = layout.cols * layout.rows;
    const pagesCount = Math.ceil(expanded.length / perPage);

    const frag = document.createDocumentFragment();

    for (let pi = 0; pi < pagesCount; pi++) {
      const pageEl = document.createElement('section');
      pageEl.className = 'print-page';

      const grid = document.createElement('div');
      grid.className = 'print-grid';

      const slice = expanded.slice(pi * perPage, (pi + 1) * perPage);
      for (const it of slice) {
        const cell = document.createElement('div');
        cell.className = 'print-cell';

        const url = getPrintUrl(it);
        if (url) {
          const img = document.createElement('img');
          img.src = url;
          img.alt = it.name || 'Card';
          img.loading = 'eager';
          cell.appendChild(img);
        }

        grid.appendChild(cell);
      }

      pageEl.appendChild(grid);
      frag.appendChild(pageEl);
    }

    els.printRoot.innerHTML = '';
    els.printRoot.appendChild(frag);
  }

  async function printToPdfViaBrowser() {
    els.spinner.hidden = false;
    setStatus('');
    try {
      buildPrintDom();

      const { total, failed } = await waitForPrintImages(els.printRoot);
      if (failed) {
        setStatus(`Some images failed to load for printing.\nLoaded: ${total - failed}/${total}\nTry again or switch to a different image size (large vs normal).`);
      }

      const cleanup = () => {
        window.removeEventListener('afterprint', cleanup);
        els.printRoot.innerHTML = '';
      };
      window.addEventListener('afterprint', cleanup);

      window.print();
    } catch (e) {
      console.error(e);
      setStatus(`ERROR: ${e?.message || e}`);
    } finally {
      els.spinner.hidden = true;
    }
  }

  async function load() {
    els.spinner.hidden = false;
    setStatus('');
    try {
      const itemsRaw = parseDeckText(els.input.value);

      if (!itemsRaw.length) {
        ITEMS = [];
        ORACLE_TO_CARD.clear();
        renderCards();
        return;
      }

      const exactPrintByLineKey = new Map();
      const nameFallbackCounts = new Map();

      for (const it of itemsRaw) {
        const nm = String(it.name || '').trim();
        if (!nm) continue;

        if (it.setCode && it.collectorNumber) {
          const print = await fetchCardBySetAndNumber(it.setCode, it.collectorNumber);
          if (print?.id && print?.oracle_id) {
            const k = `${nm.toLowerCase()}|${String(it.setCode).toLowerCase()}|${String(it.collectorNumber).toLowerCase()}`;
            exactPrintByLineKey.set(k, { print, qty: it.qty || 1, name: nm });
            ORACLE_TO_CARD.set(print.oracle_id, print);
            continue;
          }
        }

        nameFallbackCounts.set(nm, (nameFallbackCounts.get(nm) || 0) + (it.qty || 1));
      }

      const fallbackNames = [...nameFallbackCounts.keys()];
      const cards = fallbackNames.length ? await fetchCollectionByNames(fallbackNames) : [];

      ORACLE_TO_CARD.clear();
      const nameToOracle = new Map();
      for (const c of cards) {
        if (c?.name && c?.oracle_id) {
          nameToOracle.set(String(c.name).toLowerCase(), c.oracle_id);
          ORACLE_TO_CARD.set(c.oracle_id, c);
        }
      }

      const oracleCounts = new Map();
      const oracleDisplayName = new Map();
      const oraclePreferredPrint = new Map();

      for (const [, v] of exactPrintByLineKey.entries()) {
        const { print, qty, name } = v;
        const oracleId = print.oracle_id;

        oracleCounts.set(oracleId, (oracleCounts.get(oracleId) || 0) + qty);
        oracleDisplayName.set(oracleId, name || print.name);

        oraclePreferredPrint.set(oracleId, {
          printId: print.id,
          ui: UI_IMG(print),
          printUrl: PRINT_IMG(print)
        });

        if (!ORACLE_TO_CARD.has(oracleId)) ORACLE_TO_CARD.set(oracleId, print);
        if (print?.id) PRINT_CACHE.set(print.id, print);
      }

      for (const [rawName, qty] of nameFallbackCounts.entries()) {
        const key = String(rawName || '').toLowerCase();
        let oracleId = nameToOracle.get(key);

        if (!oracleId) {
          const found = cards.find(c => String(c?.name || '').toLowerCase() === key);
          oracleId = found?.oracle_id;
          if (oracleId && found) {
            ORACLE_TO_CARD.set(oracleId, found);
            oracleDisplayName.set(oracleId, found.name);
          }
        }
        if (!oracleId) continue;

        oracleCounts.set(oracleId, (oracleCounts.get(oracleId) || 0) + qty);
        const c = ORACLE_TO_CARD.get(oracleId);
        if (c?.name && !oracleDisplayName.has(oracleId)) oracleDisplayName.set(oracleId, c.name);
      }

      ITEMS = [...oracleCounts.entries()].map(([oracleId, qty]) => {
        const c = ORACLE_TO_CARD.get(oracleId);
        const pref = oraclePreferredPrint.get(oracleId);

        return {
          oracle_id: oracleId,
          name: oracleDisplayName.get(oracleId) || c?.name || 'Unknown',
          qty,

          chosen_print_id: pref?.printId || null,
          chosen_img_ui: pref?.ui || null,
          chosen_img_print: pref?.printUrl || null
        };
      }).sort((a,b) => a.name.localeCompare(b.name));

      renderCards();
      setStatus(`Loaded ${ITEMS.length} unique cards. Prints preselected where provided.`);
    } catch (e) {
      console.error(e);
      setStatus(`ERROR: ${e?.message || e}`);
    } finally {
      els.spinner.hidden = true;
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    els.gapMm.value = '3';
    els.layout.value = 'LETTER_3x3';

    els.loadBtn.addEventListener('click', load);

    els.clearBtn.addEventListener('click', () => {
      els.input.value = '';
      els.cards.innerHTML = '';
      els.empty.hidden = false;
      setStatus('');
      ITEMS = [];
      ORACLE_TO_CARD.clear();
      ORACLE_TO_PRINTS.clear();
      PRINT_CACHE.clear();
      els.printRoot.innerHTML = '';
    });

    els.scaleDown.addEventListener('click', () => {
      els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) - 1, 50, 140));
    });
    els.scaleUp.addEventListener('click', () => {
      els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) + 1, 50, 140));
    });
    els.scalePct.addEventListener('change', () => {
      els.scalePct.value = String(clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140));
    });

    els.printBtn.addEventListener('click', printToPdfViaBrowser);

    els.cards.addEventListener('click', (e) => {
      const btn = e.target.closest('button[data-action="art"]');
      if (!btn) return;
      const oracleId = btn.getAttribute('data-oracle');
      if (!oracleId) return;
      openArtModalFor(oracleId);
    });

    els.artClose.addEventListener('click', closeArtModal);
    els.artBackdrop.addEventListener('click', (e) => {
      if (e.target === els.artBackdrop) closeArtModal();
    });

    els.artBody.addEventListener('click', (e) => {
      const tile = e.target.closest('.print-tile');
      if (!tile || !MODAL_ORACLE) return;

      const pid = tile.getAttribute('data-print-id');
      if (!pid) return;

      els.artBody.querySelectorAll('.print-tile.selected').forEach(n => n.classList.remove('selected'));
      tile.classList.add('selected');

      applySelectedPrint(MODAL_ORACLE, pid);
    });
  });
</script>

  <!-- Background video logic -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
      const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
      const allowVideo = isFast && isWifiLike;

      const wrap = document.getElementById('bgVideo');
      const vid  = document.getElementById('bgVideoEl');
      if (!wrap || !vid) return;

      if (!allowVideo) { wrap.style.display = 'none'; return; }

      vid.src = '/assets/Blackhole_Animtation.mp4';
      const onReady = () => {
        wrap.classList.add('ready');
        const p = vid.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
      };
      vid.addEventListener('canplay', onReady, { once: true });
      vid.addEventListener('loadeddata', onReady, { once: true });
      vid.addEventListener('loadedmetadata', () => { wrap.classList.add('ready'); }, { once: true });
    });
  </script>

  <!-- Partials loader -->
  <script>
    (async () => {
      try {
        async function loadPartial(url) {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) return null;
          const html = await res.text();
          const tpl = document.createElement('template');
          tpl.innerHTML = html.trim();
          tpl.content.querySelectorAll('style').forEach(st => {
            document.head.appendChild(st.cloneNode(true));
            st.remove();
          });
          return tpl.content.firstElementChild || null;
        }

        const header = document.getElementById('site-header');
        const navEl = await loadPartial('/partials/nav.html');
        if (header && navEl) {
          header.innerHTML = '';
          header.appendChild(navEl);
          initNav(header);
        }

        const discordEl = await loadPartial('/partials/discord.html');
        if (discordEl) document.body.appendChild(discordEl);

        const footerEl = await loadPartial('/partials/footer.html');
        if (footerEl) document.body.appendChild(footerEl);

        function initNav(scope) {
          const btn = scope.querySelector('.menu-toggle');
          const panel = scope.querySelector('#nav-panel');
          if (btn && panel) {
            btn.addEventListener('click', () => {
              const open = panel.classList.toggle('open');
              btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            });
          }
          const here = location.pathname.toLowerCase().replace(/\/+$/, '');
          scope.querySelectorAll('.nav-link').forEach(a => {
            let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
            if (href === '/blog/') href = '/blog';
            if (here === href || ((here === '' || here === '/') && href === '/index.html')) {
              a.setAttribute('aria-current', 'page');
            }
            if (here.includes('/projects')) a.setAttribute('aria-current', 'page');
            if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
          });
        }
      } catch (e) {
        console.warn('Partial load failed:', e);
      }
    })();
  </script>
</body>
</html>
