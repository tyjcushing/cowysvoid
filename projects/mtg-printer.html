<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Print Sheet Builder — Cowy’s Void</title>
  <meta name="description" content="Paste a list of Magic cards, select specific prints, and generate a print-ready PDF." />
  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <link rel="stylesheet" href="/assets/css/void.css">
  <style>
    .controls-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .control { display:flex; gap:8px; align-items:center; }
    .control select, .control input[type="number"] { min-height: 38px; }
    .pill-lite { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .status-box { margin-top:10px; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: .95; }
    .cards-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 12px; margin-top:12px; }
    .card-tile { display:flex; flex-direction:column; gap:10px; padding: 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.12); background: rgba(10,10,16,.55); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .card-top { display:flex; gap:10px; align-items:flex-start; }
    .card-meta { flex: 1; min-width: 0; }
    .card-meta .name { font-weight: 700; line-height:1.15; }
    .card-meta .sub { color: var(--muted); font-size: 12px; margin-top: 4px; }
    .qty-badge { align-self:flex-start; padding: 4px 10px; border-radius: 999px; font-weight: 700; background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.14); }
    .img-wrap { display:flex; justify-content:center; }
    .img-wrap img { width: 100%; max-width: 320px; height: auto; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.25); }
    .tile-actions { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .mini { font-size: 12px; color: var(--muted); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }

    select.pick-black {
      background: #000 !important;
      color: #fff !important;
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 12px;
      padding: 8px 10px;
      min-height: 40px;
    }
    select.pick-black option { background:#000; color:#fff; }

    .modal-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      width: min(980px, 96vw);
      max-height: min(90vh, 900px);
      overflow: hidden;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,10,16,.92);
      box-shadow: 0 30px 80px rgba(0,0,0,.6);
      display:flex;
      flex-direction:column;
    }
    .modal-header {
      position: sticky;
      top: 0;
      z-index: 2;
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(10,10,16,.96);
    }
    .modal-title { font-weight: 800; }
    .modal-body {
      padding: 12px 14px 14px;
      overflow:auto;
    }
    .prints-grid {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
    }
    .print-tile {
      border-radius: 12px;
      border: 2px solid transparent;
      background: rgba(255,255,255,.04);
      padding: 8px;
      cursor: pointer;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      user-select: none;
    }
    .print-tile:hover { transform: translateY(-1px); background: rgba(255,255,255,.06); }
    .print-tile.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset; }
    .print-tile img {
      width: 100%;
      height: auto;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      display:block;
    }
    .print-cap {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.2;
    }
  </style>
</head>

<body>
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <div class="app-layer">
    <header id="site-header" aria-label="Primary"></header>

    <main class="container">
      <section class="panel page-panel solid-surface">
        <header class="page">
          <h1>Print Sheet Builder</h1>
          <p class="sub">Paste cards, choose specific art, then generate a print-ready PDF.</p>
        </header>

        <div class="toolbar toolbar-wide" role="region" aria-label="Paste cards">
          <label class="input input-solid solid-input" style="align-items:start">
            <textarea id="deckInput" class="textarea" placeholder="Examples:
1 Sol Ring
3x Dark Ritual
Arcane Signet
Commander: Alela, Artful Provocateur

(Quantities supported; comments with # or // ignored)"></textarea>
          </label>
        </div>

        <div class="controls-row">
          <button id="loadBtn" class="btn">Load Cards</button>
          <button id="clearBtn" class="btn ghost solid-ghost-btn" type="button">Clear</button>

          <span id="spinner" class="spinner" hidden>
            <span class="spin-dot" aria-hidden="true"></span>
            <span class="inline-hint">Loading…</span>
          </span>

          <span class="pill-lite">
            <strong>Scale</strong>
            <span class="control" style="display:inline-flex; gap:6px; margin-left:8px;">
              <button id="scaleDown" class="btn ghost solid-ghost-btn" type="button" aria-label="Decrease scale">−</button>
              <input id="scalePct" type="number" min="50" max="140" step="1" value="100"
                     style="width:84px; text-align:center; border-radius:12px;"
                     aria-label="Scale percent">
              <button id="scaleUp" class="btn ghost solid-ghost-btn" type="button" aria-label="Increase scale">+</button>
            </span>
          </span>

          <span class="pill-lite control" title="Gap / bleed between cards on the PDF sheet">
            <label for="gapMm"><strong>Gap</strong></label>
            <select id="gapMm" class="pick-black" aria-label="Gap setting">
              <option value="0">No gap (0mm)</option>
              <option value="0.2">0.2mm</option>
              <option value="3" selected>3mm (default)</option>
            </select>
          </span>

          <span class="pill-lite control">
            <label for="layout"><strong>Layout</strong></label>
            <select id="layout" class="pick-black" aria-label="Print layout">
              <option value="LETTER_3x3" selected>US Letter (8.5×11) · 3×3 (default)</option>
              <option value="LETTER_3x4">US Letter (8.5×11) · 3×4 (tight)</option>
              <option value="A4_3x3">A4 · 3×3</option>
              <option value="A4_3x4">A4 · 3×4 (tight)</option>
            </select>
          </span>

          <span class="pill-lite control">
            <button id="printBtn" class="btn">Print</button>
          </span>

          <span class="pill-lite control" title="Opens the proxied image for the first card (debug)">
            <button id="debugImgBtn" class="btn ghost solid-ghost-btn" type="button">Debug Image</button>
          </span>
        </div>

        <div class="inline-hint" style="margin-top:8px">
          If your PDF shows placeholders, check the status output below — it will tell you exactly which image fetch/decode failed.
        </div>

        <div id="status" class="status-box"></div>
      </section>

      <section class="panel solid-surface">
        <h2>Cards</h2>
        <div id="empty" class="empty">Paste cards and click Load Cards.</div>
        <div id="cards" class="cards-grid"></div>
      </section>
    </main>
  </div>

  <div id="artBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="Choose alternate art">
    <div class="modal">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="artTitle">Choose Art</div>
          <div class="inline-hint" id="artSub" style="margin-top:4px">Click an image to select.</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="artClose" class="btn ghost solid-ghost-btn" type="button">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div id="artBody" class="prints-grid"></div>
      </div>
    </div>
  </div>

  <script>
    const SCRY_COLLECTION = 'https://api.scryfall.com/cards/collection';
    const SCRY_SEARCH_PRINTS = (oracleId) =>
      `https://api.scryfall.com/cards/search?order=released&q=oracleid%3A${encodeURIComponent(oracleId)}&unique=prints`;

    const UI_IMG = (card) => card?.image_uris?.normal || card?.card_faces?.[0]?.image_uris?.normal || '';
    const PDF_IMG = (card) =>
      card?.image_uris?.png || card?.image_uris?.large || card?.image_uris?.normal ||
      card?.card_faces?.[0]?.image_uris?.png || card?.card_faces?.[0]?.image_uris?.large || card?.card_faces?.[0]?.image_uris?.normal || '';

    const PROXY_IMG = (url) => `/img?url=${encodeURIComponent(url)}`;

    const els = {
      input: document.getElementById('deckInput'),
      loadBtn: document.getElementById('loadBtn'),
      clearBtn: document.getElementById('clearBtn'),
      spinner: document.getElementById('spinner'),
      cards: document.getElementById('cards'),
      empty: document.getElementById('empty'),
      status: document.getElementById('status'),

      scaleDown: document.getElementById('scaleDown'),
      scaleUp: document.getElementById('scaleUp'),
      scalePct: document.getElementById('scalePct'),
      gapMm: document.getElementById('gapMm'),
      layout: document.getElementById('layout'),
      printBtn: document.getElementById('printBtn'),
      debugImgBtn: document.getElementById('debugImgBtn'),

      artBackdrop: document.getElementById('artBackdrop'),
      artTitle: document.getElementById('artTitle'),
      artSub: document.getElementById('artSub'),
      artBody: document.getElementById('artBody'),
      artClose: document.getElementById('artClose'),
    };

    function esc(v) {
      const s = (v == null) ? '' : String(v);
      return s.replace(/[&<>\"']/g, m => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[m]));
    }
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function setStatus(msg) { els.status.textContent = msg || ''; }

    function stripNameAnnotations(s = '') {
      s = String(s || '').trim();
      const cuts = [s.indexOf('['), s.indexOf('{'), s.indexOf('('), s.indexOf('^^')].filter(i => i >= 0);
      if (!cuts.length) return s;
      return s.slice(0, Math.min(...cuts)).trim();
    }

    function parseDeckText(text) {
      const lines = (text || '').replace(/\r\n?/g, '\n').split('\n');
      const items = [];
      let section = 'Deck';

      for (let raw of lines) {
        let line = String(raw || '').trim();
        if (!line) continue;
        line = line.replace(/\s*\/\/.*$/,'').replace(/\s*#.*$/,'').trim();
        if (!line) continue;

        if (/^commander:?$/i.test(line))   { section = 'Commander'; continue; }
        if (/^companion:?$/i.test(line))   { section = 'Companion'; continue; }
        if (/^deck:?$/i.test(line))        { section = 'Deck';      continue; }
        if (/^sideboard:?$/i.test(line))   { section = 'Sideboard'; continue; }
        if (/^maybeboard:?$/i.test(line))  { section = 'Maybeboard';continue; }

        let m = line.match(/^commander:\s*(.+)$/i);
        if (m) { items.push({ qty: 1, name: stripNameAnnotations(m[1]), section: 'Commander' }); continue; }

        m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
        if (m) { items.push({ qty: parseInt(m[1], 10), name: stripNameAnnotations(m[2]), section }); continue; }

        items.push({ qty: 1, name: stripNameAnnotations(line), section });
      }
      return items;
    }

    function countByName(items) {
      const m = new Map();
      for (const it of items) {
        if (!it?.name) continue;
        const k = it.name;
        m.set(k, (m.get(k) || 0) + (it.qty || 1));
      }
      return m;
    }

    let ITEMS = [];
    const ORACLE_TO_CARD = new Map();
    const ORACLE_TO_PRINTS = new Map();
    const PRINT_CACHE = new Map();
    let MODAL_ORACLE = null;

    async function fetchCollectionByNames(names) {
      const CHUNK = 70;
      const uniq = [...new Set(names.filter(Boolean))];
      const out = [];

      for (let i = 0; i < uniq.length; i += CHUNK) {
        const slice = uniq.slice(i, i + CHUNK);
        const body = { identifiers: slice.map(n => ({ name: n })) };

        const r = await fetch(SCRY_COLLECTION, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        if (!r.ok) continue;
        const j = await r.json();
        (j.data || []).forEach(c => out.push(c));
      }
      return out;
    }

    async function fetchPrintsForOracle(oracleId) {
      if (ORACLE_TO_PRINTS.has(oracleId)) return ORACLE_TO_PRINTS.get(oracleId);

      const url = SCRY_SEARCH_PRINTS(oracleId);
      const r = await fetch(url);
      if (!r.ok) {
        ORACLE_TO_PRINTS.set(oracleId, []);
        return [];
      }
      const j = await r.json();
      const prints = (j.data || []);
      ORACLE_TO_PRINTS.set(oracleId, prints);

      for (const p of prints) {
        if (p?.id) PRINT_CACHE.set(p.id, p);
      }
      return prints;
    }

    function renderCards() {
      els.cards.innerHTML = '';
      els.empty.hidden = ITEMS.length > 0;

      els.cards.innerHTML = ITEMS.map(it => {
        const img = it.chosen_img_ui || UI_IMG(ORACLE_TO_CARD.get(it.oracle_id)) || '';
        const subtitle = (ORACLE_TO_CARD.get(it.oracle_id)?.set_name)
          ? ORACLE_TO_CARD.get(it.oracle_id).set_name
          : '—';

        return `
          <article class="card-tile" data-oracle="${esc(it.oracle_id)}">
            <div class="card-top">
              <div class="card-meta">
                <div class="name">${esc(it.name)}</div>
                <div class="sub">${esc(subtitle)}</div>
              </div>
              <div class="qty-badge">×${it.qty}</div>
            </div>

            <div class="img-wrap">
              ${img
                ? `<img loading="lazy" src="${esc(img)}" alt="${esc(it.name)}">`
                : `<div class="inline-hint">No image available.</div>`
              }
            </div>

            <div class="tile-actions">
              <div class="mini">Selected: ${it.chosen_print_id ? 'Alt art' : 'Default'}</div>
              <div class="btn-row">
                <button class="btn ghost solid-ghost-btn" type="button" data-action="art" data-oracle="${esc(it.oracle_id)}">Swap Art</button>
              </div>
            </div>
          </article>
        `;
      }).join('');
    }

    function openArtModalFor(oracleId) {
      MODAL_ORACLE = oracleId;
      const it = ITEMS.find(x => x.oracle_id === oracleId);
      els.artTitle.textContent = it ? `Choose Art — ${it.name}` : 'Choose Art';
      els.artSub.textContent = 'Click an image to select.';
      els.artBody.innerHTML = `<div class="inline-hint">Loading prints…</div>`;
      els.artBackdrop.style.display = 'flex';

      fetchPrintsForOracle(oracleId).then(prints => {
        const currentPrintId = it?.chosen_print_id || null;

        if (!prints.length) {
          els.artBody.innerHTML = `<div class="inline-hint">No alternate prints found.</div>`;
          return;
        }

        els.artBody.innerHTML = prints.map(p => {
          const ui = UI_IMG(p);
          const set = p?.set_name || p?.set || '';
          const cn = p?.collector_number || '';
          const selected = (currentPrintId && p.id === currentPrintId) ? 'selected' : '';
          return `
            <div class="print-tile ${selected}" data-print-id="${esc(p.id)}">
              ${ui ? `<img loading="lazy" src="${esc(ui)}" alt="${esc(p.name)}">` : `<div class="inline-hint">No image</div>`}
              <div class="print-cap">${esc(set)} · ${esc(cn)}</div>
            </div>
          `;
        }).join('');
      }).catch(() => {
        els.artBody.innerHTML = `<div class="inline-hint">Failed to load prints.</div>`;
      });
    }

    function closeArtModal() {
      MODAL_ORACLE = null;
      els.artBackdrop.style.display = 'none';
      els.artBody.innerHTML = '';
    }

    function applySelectedPrint(oracleId, printId) {
      const it = ITEMS.find(x => x.oracle_id === oracleId);
      const p = PRINT_CACHE.get(printId);
      if (!it || !p) return;

      it.chosen_print_id = printId;
      it.chosen_img_ui = UI_IMG(p);
      it.chosen_img_pdf = PDF_IMG(p);
      renderCards();
    }

    async function loadPdfLib() {
      if (window.PDFLib) return window.PDFLib;

      await new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = 'https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js';
        s.onload = resolve;
        s.onerror = () => reject(new Error('Failed to load pdf-lib'));
        document.head.appendChild(s);
      });

      if (!window.PDFLib) throw new Error('pdf-lib loaded but PDFLib is missing');
      return window.PDFLib;
    }

    function layoutSpec(value) {
      const A4 = { w: 210, h: 297 };
      const LETTER = { w: 215.9, h: 279.4 };

      switch (value) {
        case 'LETTER_3x4': return { page: LETTER, cols: 3, rows: 4 };
        case 'A4_3x3':     return { page: A4, cols: 3, rows: 3 };
        case 'A4_3x4':     return { page: A4, cols: 3, rows: 4 };
        case 'LETTER_3x3':
        default:           return { page: LETTER, cols: 3, rows: 3 };
      }
    }

    function mmToPt(mm) { return mm * (72 / 25.4); }

    async function blobToUint8(blob) {
      const buf = await blob.arrayBuffer();
      return new Uint8Array(buf);
    }

    async function loadImageFromBlob(blob) {
      return await new Promise((resolve, reject) => {
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.decoding = 'async';
        img.onload = () => {
          URL.revokeObjectURL(url);
          const w = img.naturalWidth || img.width;
          const h = img.naturalHeight || img.height;
          if (!w || !h) {
            reject(new Error('Image decoded but has 0x0 dimensions'));
            return;
          }
          resolve(img);
        };
        img.onerror = () => {
          URL.revokeObjectURL(url);
          reject(new Error('Image decode failed (img.onerror)'));
        };
        img.src = url;
      });
    }

    async function blobToPngBytes(blob) {
      const img = await loadImageFromBlob(blob);

      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth || img.width;
      canvas.height = img.naturalHeight || img.height;

      const ctx = canvas.getContext('2d', { alpha: true });
      ctx.drawImage(img, 0, 0);

      const pngBlob = await new Promise((resolve, reject) => {
        canvas.toBlob((b) => (b ? resolve(b) : reject(new Error('canvas.toBlob failed'))), 'image/png');
      });

      return await blobToUint8(pngBlob);
    }

    async function fetchAsPngBytes(proxiedUrl, originalUrlHint) {
      const r = await fetch(proxiedUrl, { cache: 'no-store' });
      const ct = (r.headers.get('content-type') || '').toLowerCase();

      if (!r.ok) {
        const t = await r.text().catch(() => '');
        throw new Error(`Fetch ${r.status} for ${originalUrlHint || proxiedUrl}\ncontent-type: ${ct || '(missing)'}\n${t.slice(0, 240)}`);
      }

      const blob = await r.blob();

      // If proxy is returning an error page, surface it clearly
      if (ct.includes('text/html') || ct.includes('application/json') || ct.startsWith('text/')) {
        const t = await blob.text().catch(() => '');
        throw new Error(
          `Proxy did not return an image for ${originalUrlHint || proxiedUrl}\n` +
          `content-type: ${ct || '(missing)'}\n` +
          `${t.slice(0, 240)}`
        );
      }

      // Convert to PNG bytes via reliable <img> decode path
      try {
        return await blobToPngBytes(blob);
      } catch (e) {
        // One more diagnostic: try to read as text to see if it's actually HTML without correct headers
        const t = await blob.text().catch(() => '');
        const head = t.slice(0, 120).replace(/\s+/g, ' ').trim();
        if (head.startsWith('<') || head.toLowerCase().includes('cloudflare')) {
          throw new Error(
            `Image decode failed; response looks like HTML for ${originalUrlHint || proxiedUrl}\n` +
            `content-type: ${ct || '(missing)'}\n` +
            `${t.slice(0, 240)}`
          );
        }
        throw new Error(`Image decode failed for ${originalUrlHint || proxiedUrl}\ncontent-type: ${ct || '(missing)'}\n${e?.message || e}`);
      }
    }

    async function embedPngFromProxy(pdf, proxiedUrl, originalUrlHint) {
      const pngBytes = await fetchAsPngBytes(proxiedUrl, originalUrlHint);
      return await pdf.embedPng(pngBytes);
    }

    async function buildPdf() {
      const PDFLib = await loadPdfLib();
      const { PDFDocument, rgb, StandardFonts } = PDFLib;

      const scalePct = clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140);
      const scale = scalePct / 100;

      const gapMm = parseFloat(els.gapMm.value);
      const gap = (isFinite(gapMm) ? gapMm : 3);

      const layout = layoutSpec(els.layout.value);

      const cardWmm = 63 * scale;
      const cardHmm = 88 * scale;

      const pageW = layout.page.w;
      const pageH = layout.page.h;

      const gridW = layout.cols * cardWmm + (layout.cols - 1) * gap;
      const gridH = layout.rows * cardHmm + (layout.rows - 1) * gap;

      const startXmm = (pageW - gridW) / 2;
      const startYmm = (pageH - gridH) / 2;

      const expanded = [];
      for (const it of ITEMS) {
        for (let i = 0; i < (it.qty || 1); i++) expanded.push(it);
      }
      if (!expanded.length) throw new Error('No cards to print.');

      const perPage = layout.cols * layout.rows;
      const pagesCount = Math.ceil(expanded.length / perPage);

      const pdf = await PDFDocument.create();
      const font = await pdf.embedFont(StandardFonts.Helvetica);

      const embedCache = new Map(); // key -> embedded png
      const errors = [];

      for (let pi = 0; pi < pagesCount; pi++) {
        const page = pdf.addPage([mmToPt(pageW), mmToPt(pageH)]);
        const slice = expanded.slice(pi * perPage, (pi + 1) * perPage);

        for (let idx = 0; idx < slice.length; idx++) {
          const it = slice[idx];
          const row = Math.floor(idx / layout.cols);
          const col = idx % layout.cols;

          const xMm = startXmm + col * (cardWmm + gap);
          const yTopMm = startYmm + row * (cardHmm + gap);
          const yMm = (pageH - yTopMm - cardHmm);

          const key = it.chosen_print_id || it.oracle_id;

          const chosenUrl = it.chosen_img_pdf || PDF_IMG(ORACLE_TO_CARD.get(it.oracle_id));
          if (!chosenUrl) continue;

          const proxiedUrl = PROXY_IMG(chosenUrl);

          try {
            let embedded = embedCache.get(key);
            if (!embedded) {
              embedded = await embedPngFromProxy(pdf, proxiedUrl, chosenUrl);
              embedCache.set(key, embedded);
            }

            page.drawImage(embedded, {
              x: mmToPt(xMm),
              y: mmToPt(yMm),
              width: mmToPt(cardWmm),
              height: mmToPt(cardHmm)
            });
          } catch (err) {
            const msg = `${it.name}: ${err?.message || err}`;
            errors.push(msg);

            // Placeholder: WHITE fill (not black) + red border + label
            page.drawRectangle({
              x: mmToPt(xMm),
              y: mmToPt(yMm),
              width: mmToPt(cardWmm),
              height: mmToPt(cardHmm),
              color: rgb(1, 1, 1),
              borderColor: rgb(0.75, 0.15, 0.15),
              borderWidth: 1
            });

            const label = 'IMAGE FAILED';
            page.drawText(label, {
              x: mmToPt(xMm) + 6,
              y: mmToPt(yMm) + 6,
              size: 9,
              font,
              color: rgb(0.75, 0.15, 0.15)
            });
          }
        }
      }

      const pdfBytes = await pdf.save();

      if (errors.length) {
        setStatus(
          `Built PDF with ${errors.length} image issue(s).\n` +
          `First few:\n- ${errors.slice(0, 8).join('\n- ')}${errors.length > 8 ? '\n…' : ''}\n\n` +
          `If these errors mention HTML/Cloudflare, your /img proxy is not returning image bytes for some URLs.`
        );
      }

      return new Blob([pdfBytes], { type: 'application/pdf' });
    }

    async function printPdf() {
      els.spinner.hidden = false;
      setStatus('');
      try {
        const blob = await buildPdf();
        const url = URL.createObjectURL(blob);
        const w = window.open(url, '_blank', 'noopener,noreferrer');

        const scalePct = clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140);
        const gapMm = parseFloat(els.gapMm.value);

        if (!w) {
          const a = document.createElement('a');
          a.href = url;
          a.download = 'mtg-print-sheet.pdf';
          a.click();
          if (!els.status.textContent) {
            setStatus(`Popup blocked. Downloaded PDF instead.\nScale: ${scalePct}% · Gap: ${gapMm}mm · Layout: ${els.layout.value}`);
          }
          return;
        }

        if (!els.status.textContent) {
          setStatus(`Opened PDF in a new tab.\nScale: ${scalePct}% · Gap: ${gapMm}mm · Layout: ${els.layout.value}`);
        }
      } catch (e) {
        console.error(e);
        setStatus(`ERROR: ${e?.message || e}`);
      } finally {
        els.spinner.hidden = true;
      }
    }

    async function debugFirstImage() {
      setStatus('');
      if (!ITEMS.length) {
        setStatus('No cards loaded. Load cards first.');
        return;
      }
      const it = ITEMS[0];
      const chosenUrl = it.chosen_img_pdf || PDF_IMG(ORACLE_TO_CARD.get(it.oracle_id));
      if (!chosenUrl) {
        setStatus('First card has no PDF image URL.');
        return;
      }
      const proxiedUrl = PROXY_IMG(chosenUrl);
      window.open(proxiedUrl, '_blank', 'noopener,noreferrer');
      setStatus(`Opened proxied image in new tab:\n${proxiedUrl}\n\nIf this tab shows HTML/error, your /img proxy is the root cause.`);
    }

    async function load() {
      els.spinner.hidden = false;
      setStatus('');
      try {
        const itemsRaw = parseDeckText(els.input.value);
        const counts = countByName(itemsRaw);
        const rawNames = [...counts.keys()];

        if (!rawNames.length) {
          ITEMS = [];
          ORACLE_TO_CARD.clear();
          renderCards();
          return;
        }

        const cards = await fetchCollectionByNames(rawNames);

        ORACLE_TO_CARD.clear();
        const nameToOracle = new Map();
        for (const c of cards) {
          if (c?.name && c?.oracle_id) {
            nameToOracle.set(String(c.name).toLowerCase(), c.oracle_id);
            ORACLE_TO_CARD.set(c.oracle_id, c);
          }
        }

        const oracleCounts = new Map();
        const oracleDisplayName = new Map();

        for (const [rawName, qty] of counts.entries()) {
          const key = String(rawName || '').toLowerCase();
          let oracleId = nameToOracle.get(key);

          if (!oracleId) {
            const found = cards.find(c => String(c?.name || '').toLowerCase() === key);
            oracleId = found?.oracle_id;
            if (oracleId && found) {
              ORACLE_TO_CARD.set(oracleId, found);
              oracleDisplayName.set(oracleId, found.name);
            }
          }
          if (!oracleId) continue;

          oracleCounts.set(oracleId, (oracleCounts.get(oracleId) || 0) + qty);
          const c = ORACLE_TO_CARD.get(oracleId);
          if (c?.name) oracleDisplayName.set(oracleId, c.name);
        }

        ITEMS = [...oracleCounts.entries()].map(([oracleId, qty]) => {
          const c = ORACLE_TO_CARD.get(oracleId);
          return {
            oracle_id: oracleId,
            name: oracleDisplayName.get(oracleId) || c?.name || 'Unknown',
            qty,
            chosen_print_id: null,
            chosen_img_ui: null,
            chosen_img_pdf: null
          };
        }).sort((a,b) => a.name.localeCompare(b.name));

        renderCards();
      } finally {
        els.spinner.hidden = true;
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      els.gapMm.value = '3';
      els.layout.value = 'LETTER_3x3';

      els.loadBtn.addEventListener('click', load);

      els.clearBtn.addEventListener('click', () => {
        els.input.value = '';
        els.cards.innerHTML = '';
        els.empty.hidden = false;
        setStatus('');
        ITEMS = [];
        ORACLE_TO_CARD.clear();
        ORACLE_TO_PRINTS.clear();
        PRINT_CACHE.clear();
      });

      els.scaleDown.addEventListener('click', () => {
        els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) - 1, 50, 140));
      });
      els.scaleUp.addEventListener('click', () => {
        els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) + 1, 50, 140));
      });
      els.scalePct.addEventListener('change', () => {
        els.scalePct.value = String(clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140));
      });

      els.printBtn.addEventListener('click', printPdf);
      els.debugImgBtn.addEventListener('click', debugFirstImage);

      els.cards.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action="art"]');
        if (!btn) return;
        const oracleId = btn.getAttribute('data-oracle');
        if (!oracleId) return;
        openArtModalFor(oracleId);
      });

      els.artClose.addEventListener('click', closeArtModal);
      els.artBackdrop.addEventListener('click', (e) => {
        if (e.target === els.artBackdrop) closeArtModal();
      });

      els.artBody.addEventListener('click', (e) => {
        const tile = e.target.closest('.print-tile');
        if (!tile || !MODAL_ORACLE) return;

        const pid = tile.getAttribute('data-print-id');
        if (!pid) return;

        els.artBody.querySelectorAll('.print-tile.selected').forEach(n => n.classList.remove('selected'));
        tile.classList.add('selected');

        applySelectedPrint(MODAL_ORACLE, pid);
      });
    });
  </script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
      const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
      const allowVideo = isFast && isWifiLike;

      const wrap = document.getElementById('bgVideo');
      const vid  = document.getElementById('bgVideoEl');
      if (!wrap || !vid) return;

      if (!allowVideo) { wrap.style.display = 'none'; return; }

      vid.src = '/assets/Blackhole_Animtation.mp4';
      const onReady = () => {
        wrap.classList.add('ready');
        const p = vid.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
      };
      vid.addEventListener('canplay', onReady, { once: true });
      vid.addEventListener('loadeddata', onReady, { once: true });
      vid.addEventListener('loadedmetadata', () => { wrap.classList.add('ready'); }, { once: true });
    });
  </script>

  <script>
    (async () => {
      try {
        async function loadPartial(url) {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) return null;
          const html = await res.text();
          const tpl = document.createElement('template');
          tpl.innerHTML = html.trim();
          tpl.content.querySelectorAll('style').forEach(st => {
            document.head.appendChild(st.cloneNode(true));
            st.remove();
          });
          return tpl.content.firstElementChild || null;
        }

        const header = document.getElementById('site-header');
        const navEl = await loadPartial('/partials/nav.html');
        if (header && navEl) {
          header.innerHTML = '';
          header.appendChild(navEl);
          initNav(header);
        }

        const discordEl = await loadPartial('/partials/discord.html');
        if (discordEl) document.body.appendChild(discordEl);

        const footerEl = await loadPartial('/partials/footer.html');
        if (footerEl) document.body.appendChild(footerEl);

        function initNav(scope) {
          const btn = scope.querySelector('.menu-toggle');
          const panel = scope.querySelector('#nav-panel');
          if (btn && panel) {
            btn.addEventListener('click', () => {
              const open = panel.classList.toggle('open');
              btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            });
          }
          const here = location.pathname.toLowerCase().replace(/\/+$/, '');
          scope.querySelectorAll('.nav-link').forEach(a => {
            let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
            if (href === '/blog/') href = '/blog';
            if (here === href || ((here === '' || here === '/') && href === '/index.html')) {
              a.setAttribute('aria-current', 'page');
            }
            if (here.includes('/projects')) a.setAttribute('aria-current', 'page');
            if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
          });
        }
      } catch (e) {
        console.warn('Partial load failed:', e);
      }
    })();
  </script>
</body>
</html>
