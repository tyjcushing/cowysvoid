<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Print Sheet Builder — Cowy’s Void</title>
  <meta name="description" content="Paste a list of Magic cards, select specific prints, and generate a print-ready PDF." />
  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <link rel="stylesheet" href="/assets/css/void.css">
  <style>
    .controls-row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .control { display:flex; gap:8px; align-items:center; }
    .control select, .control input[type="number"] { min-height: 38px; }
    .pill-lite { padding: 6px 10px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.12); }
    .status-box { margin-top:10px; white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; opacity: .95; }
    .cards-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap: 12px; margin-top:12px; }
    .card-tile { display:flex; flex-direction:column; gap:10px; padding: 12px; border-radius: 14px; border:1px solid rgba(255,255,255,.12); background: rgba(10,10,16,.55); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .card-top { display:flex; gap:10px; align-items:flex-start; }
    .card-meta { flex: 1; min-width: 0; }
    .card-meta .name { font-weight: 700; line-height:1.15; }
    .card-meta .sub { color: var(--muted); font-size: 12px; margin-top: 4px; }
    .qty-badge { align-self:flex-start; padding: 4px 10px; border-radius: 999px; font-weight: 700; background: rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.14); }
    .img-wrap { display:flex; justify-content:center; }
    .img-wrap img { width: 100%; max-width: 320px; height: auto; border-radius: 12px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.25); }
    .tile-actions { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .mini { font-size: 12px; color: var(--muted); }
    .btn-row { display:flex; gap:10px; flex-wrap:wrap; }

    select.pick-black {
      background: #000 !important;
      color: #fff !important;
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 12px;
      padding: 8px 10px;
      min-height: 40px;
    }
    select.pick-black option { background:#000; color:#fff; }

    /* Modal */
    .modal-backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,.65);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 9999;
      padding: 16px;
    }
    .modal {
      width: min(980px, 96vw);
      max-height: min(90vh, 900px);
      overflow: hidden;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,10,16,.92);
      box-shadow: 0 30px 80px rgba(0,0,0,.6);
      display:flex;
      flex-direction:column;
    }
    .modal-header {
      position: sticky;
      top: 0;
      z-index: 2;
      display:flex;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(10,10,16,.96);
    }
    .modal-title { font-weight: 800; }
    .modal-body { padding: 12px 14px 14px; overflow:auto; }
    .prints-grid { display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 12px; }
    .print-tile {
      border-radius: 12px;
      border: 2px solid transparent;
      background: rgba(255,255,255,.04);
      padding: 8px;
      cursor: pointer;
      transition: transform .08s ease, border-color .08s ease, background .08s ease;
      user-select: none;
    }
    .print-tile:hover { transform: translateY(-1px); background: rgba(255,255,255,.06); }
    .print-tile.selected { border-color: var(--accent); box-shadow: 0 0 0 2px rgba(0,0,0,.35) inset; }
    .print-tile img { width: 100%; height: auto; border-radius: 10px; border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.25); display:block; }
    .print-cap { margin-top: 6px; font-size: 11px; color: var(--muted); line-height: 1.2; }

    /* ---------------- PRINT SHEET ---------------- */
    #printRoot { display:none; }

    @media print {
      /* Hide the app UI */
      body { background: #fff !important; }
      .bg-video, .app-layer { display:none !important; }

      /* Show print root */
      #printRoot { display:block !important; }

      /* Remove any default margins */
      @page { margin: 0; }
    }

    /* These vars get set in JS right before printing */
    #printRoot {
      --page-w-mm: 215.9;
      --page-h-mm: 279.4;
      --cols: 3;
      --rows: 3;
      --gap-mm: 3;
      --card-w-mm: 63;
      --card-h-mm: 88;
    }

    .print-page {
      width: calc(var(--page-w-mm) * 1mm);
      height: calc(var(--page-h-mm) * 1mm);
      page-break-after: always;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .print-grid {
      display:grid;
      grid-template-columns: repeat(var(--cols), calc(var(--card-w-mm) * 1mm));
      grid-template-rows: repeat(var(--rows), calc(var(--card-h-mm) * 1mm));
      gap: calc(var(--gap-mm) * 1mm);
      align-content:center;
      justify-content:center;
    }
    .print-cell {
      width: calc(var(--card-w-mm) * 1mm);
      height: calc(var(--card-h-mm) * 1mm);
      overflow:hidden;
      background:#fff;
    }
    .print-cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display:block;
    }
  </style>
</head>

<body>
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <div class="app-layer">
    <header id="site-header" aria-label="Primary"></header>

    <main class="container">
      <section class="panel page-panel solid-surface">
        <header class="page">
          <h1>Print Sheet Builder</h1>
          <p class="sub">Paste cards, choose specific art, then generate a print-ready PDF.</p>
        </header>

        <div class="toolbar toolbar-wide" role="region" aria-label="Paste cards">
          <label class="input input-solid solid-input" style="align-items:start">
            <textarea id="deckInput" class="textarea" placeholder="Examples:
Fowl Strike
1 Sol Ring
3x Dark Ritual
1 Arcane Signet (SLD) 1492
Commander: Alela, Artful Provocateur

(Quantities supported; comments with # or // ignored)"></textarea>
          </label>
        </div>

        <div class="controls-row">
          <button id="loadBtn" class="btn">Load Cards</button>
          <button id="clearBtn" class="btn ghost solid-ghost-btn" type="button">Clear</button>

          <span id="spinner" class="spinner" hidden>
            <span class="spin-dot" aria-hidden="true"></span>
            <span class="inline-hint">Loading…</span>
          </span>

          <span class="">
            <strong>Scale</strong>
            <span class="control" style="display:inline-flex; gap:6px; margin-left:8px;">
              <button id="scaleDown" class="btn ghost solid-ghost-btn" type="button" aria-label="Decrease scale">−</button>
              <input id="scalePct" type="number" min="50" max="140" step="1" value="101"
                     style="width:84px; text-align:center; border-radius:12px;"
                     aria-label="Scale percent">
              <button id="scaleUp" class="btn ghost solid-ghost-btn" type="button" aria-label="Increase scale">+</button>
            </span>
          </span>

          <span class="control" title="Gap / bleed between cards on the PDF sheet">
            <label for="gapMm"><strong>Gap</strong></label>
            <select id="gapMm" class="pick-black" aria-label="Gap setting">
              <option value="0">0mm</option>
              <option value="0.2">0.2mm</option>
              <option value="3" selected>3mm</option>
            </select>
          </span>

          <span class="control">
            <label for="layout"><strong>Layout</strong></label>
            <select id="layout" class="pick-black" aria-label="Print layout">
              <option value="LETTER_3x3" selected>US Letter (8.5×11) · 3×3 </option>
              <option value="LETTER_3x4">US Letter (8.5×11) · 3×4</option>
              <option value="A4_3x3">A4 · 3×3</option>
              <option value="A4_3x4">A4 · 3×4</option>
            </select>
          </span>

            <button id="printBtn" class="btn">Print</button>

        </div>

        <!--  Under line printing hint goes here.
        <div class="inline-hint" style="margin-top:8px">
        </div>-->

        <div id="status" class="status-box"></div>
      </section>

      <section class="panel solid-surface">
        <h2>Cards</h2>
        <div id="empty" class="empty">Paste cards and click Load Cards.</div>
        <div id="cards" class="cards-grid"></div>
      </section>
    </main>
  </div>

  <!-- PRINT ROOT (hidden until printing) -->
  <div id="printRoot" aria-hidden="true"></div>

  <!-- Art Modal -->
  <div id="artBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-label="Choose alternate art">
    <div class="modal">
      <div class="modal-header">
        <div>
          <div class="modal-title" id="artTitle">Choose Art</div>
          <div class="inline-hint" id="artSub" style="margin-top:4px">Click an image to select.</div>
        </div>
        <div style="display:flex; gap:10px; align-items:center;">
          <button id="artClose" class="btn ghost solid-ghost-btn" type="button">Close</button>
        </div>
      </div>
      <div class="modal-body">
        <div id="artBody" class="prints-grid"></div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Constants ----------
    const SCRY_COLLECTION = 'https://api.scryfall.com/cards/collection';
    const SCRY_SEARCH_PRINTS = (oracleId) =>
      `https://api.scryfall.com/cards/search?order=released&q=oracleid%3A${encodeURIComponent(oracleId)}&unique=prints`;

    const UI_IMG = (card) => card?.image_uris?.normal || card?.card_faces?.[0]?.image_uris?.normal || '';
    const PRINT_IMG = (card) =>
      card?.image_uris?.large || card?.image_uris?.normal ||
      card?.card_faces?.[0]?.image_uris?.large || card?.card_faces?.[0]?.image_uris?.normal || '';

    const els = {
      input: document.getElementById('deckInput'),
      loadBtn: document.getElementById('loadBtn'),
      clearBtn: document.getElementById('clearBtn'),
      spinner: document.getElementById('spinner'),
      cards: document.getElementById('cards'),
      empty: document.getElementById('empty'),
      status: document.getElementById('status'),

      scaleDown: document.getElementById('scaleDown'),
      scaleUp: document.getElementById('scaleUp'),
      scalePct: document.getElementById('scalePct'),
      gapMm: document.getElementById('gapMm'),
      layout: document.getElementById('layout'),
      printBtn: document.getElementById('printBtn'),

      artBackdrop: document.getElementById('artBackdrop'),
      artTitle: document.getElementById('artTitle'),
      artSub: document.getElementById('artSub'),
      artBody: document.getElementById('artBody'),
      artClose: document.getElementById('artClose'),

      printRoot: document.getElementById('printRoot'),
    };

    // ---------- Safe helpers ----------
    function esc(v) {
      const s = (v == null) ? '' : String(v);
      return s.replace(/[&<>\"']/g, m => ({
        '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
      }[m]));
    }
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function setStatus(msg) { els.status.textContent = msg || ''; }

    function stripNameAnnotations(s = '') {
      s = String(s || '').trim();
      const cuts = [s.indexOf('['), s.indexOf('{'), s.indexOf('('), s.indexOf('^^')].filter(i => i >= 0);
      if (!cuts.length) return s;
      return s.slice(0, Math.min(...cuts)).trim();
      
    }

    async function fetchCardBySetAndNumber(setCode, collectorNumber) {
        const set = String(setCode || '').trim().toLowerCase();
        const cn = String(collectorNumber || '').trim();

        if (!set || !cn) return null;

        const url = `https://api.scryfall.com/cards/${encodeURIComponent(set)}/${encodeURIComponent(cn)}`;
        const r = await fetch(url);
        if (!r.ok) return null;
        return await r.json();
    }


    function parseDeckText(text) {
        const lines = (text || '').replace(/\r\n?/g, '\n').split('\n');
        const items = [];
        let section = 'Deck';

        for (let raw of lines) {
            let line = String(raw || '').trim();
            if (!line) continue;

            // strip inline comments
            line = line.replace(/\s*\/\/.*$/,'').replace(/\s*#.*$/,'').trim();
            if (!line) continue;

            // section headers
            if (/^commander:?$/i.test(line))   { section = 'Commander'; continue; }
            if (/^companion:?$/i.test(line))   { section = 'Companion'; continue; }
            if (/^deck:?$/i.test(line))        { section = 'Deck';      continue; }
            if (/^sideboard:?$/i.test(line))   { section = 'Sideboard'; continue; }
            if (/^maybeboard:?$/i.test(line))  { section = 'Maybeboard';continue; }

            // Commander: prefix
            let m = line.match(/^commander:\s*(.+)$/i);
            if (m) {
            const parsed = parseLineWithPrintHints(m[1]);
            items.push({ qty: 1, section: 'Commander', ...parsed });
            continue;
            }

            // quantity prefix
            m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
            if (m) {
            const qty = parseInt(m[1], 10);
            const parsed = parseLineWithPrintHints(m[2]);
            items.push({ qty, section, ...parsed });
            continue;
            }

            // default qty 1
            const parsed = parseLineWithPrintHints(line);
            items.push({ qty: 1, section, ...parsed });
        }

        return items;
        }

        function parseLineWithPrintHints(line) {
        // Example: "Cavern of Souls (LCI) 410d *F*"
        // We want: name="Cavern of Souls", setCode="LCI", collectorNumber="410d"

        let s = String(line || '').trim();

        // Remove trailing *...* tokens like *F* or *E* or *Foil*
        s = s.replace(/\s+\*[^*]+\*\s*$/g, '').trim();

        // Extract "(SET)" and the next token as collector number
        // Set codes are typically 3-5 chars, letters/numbers
        const m = s.match(/^(.*?)(?:\s+\(([A-Za-z0-9]{2,6})\))\s+([0-9]+[A-Za-z]?)\s*$/);
        if (m) {
            const nameRaw = m[1];
            const setCode = m[2];
            const collectorNumber = m[3];
            return {
            name: stripNameAnnotations(nameRaw),
            setCode: setCode,
            collectorNumber: collectorNumber
            };
        }

        return {
            name: stripNameAnnotations(s),
            setCode: null,
            collectorNumber: null
        };
        }


    function countByName(items) {
      const m = new Map();
      for (const it of items) {
        if (!it?.name) continue;
        const k = it.name;
        m.set(k, (m.get(k) || 0) + (it.qty || 1));
      }
      return m;
    }

    // ---------- State ----------
    let ITEMS = [];
    const ORACLE_TO_CARD = new Map();       // oracle_id -> canonical card object
    const ORACLE_TO_PRINTS = new Map();     // oracle_id -> array of prints
    const PRINT_CACHE = new Map();          // printId -> print card object
    let MODAL_ORACLE = null;

    // ---------- Scryfall ----------
    async function fetchCollectionByNames(names) {
      const CHUNK = 70;
      const uniq = [...new Set(names.filter(Boolean))];
      const out = [];

      for (let i = 0; i < uniq.length; i += CHUNK) {
        const slice = uniq.slice(i, i + CHUNK);
        const body = { identifiers: slice.map(n => ({ name: n })) };

        const r = await fetch(SCRY_COLLECTION, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        if (!r.ok) continue;
        const j = await r.json();
        (j.data || []).forEach(c => out.push(c));
      }
      return out;
    }

    async function fetchPrintsForOracle(oracleId) {
      if (ORACLE_TO_PRINTS.has(oracleId)) return ORACLE_TO_PRINTS.get(oracleId);

      const url = SCRY_SEARCH_PRINTS(oracleId);
      const r = await fetch(url);
      if (!r.ok) {
        ORACLE_TO_PRINTS.set(oracleId, []);
        return [];
      }
      const j = await r.json();
      const prints = (j.data || []);
      ORACLE_TO_PRINTS.set(oracleId, prints);

      for (const p of prints) {
        if (p?.id) PRINT_CACHE.set(p.id, p);
      }
      return prints;
    }

    // ---------- Render ----------
    function renderCards() {
      els.cards.innerHTML = '';
      els.empty.hidden = ITEMS.length > 0;

      els.cards.innerHTML = ITEMS.map(it => {
        const img = it.chosen_img_ui || UI_IMG(ORACLE_TO_CARD.get(it.oracle_id)) || '';
        const subtitle = (ORACLE_TO_CARD.get(it.oracle_id)?.set_name)
          ? ORACLE_TO_CARD.get(it.oracle_id).set_name
          : '—';

        return `
          <article class="card-tile" data-oracle="${esc(it.oracle_id)}">
            <div class="card-top">
              <div class="card-meta">
                <div class="name">${esc(it.name)}</div>
                <div class="sub">${esc(subtitle)}</div>
              </div>
              <div class="qty-badge">×${it.qty}</div>
            </div>

            <div class="img-wrap">
              ${img
                ? `<img loading="lazy" src="${esc(img)}" alt="${esc(it.name)}">`
                : `<div class="inline-hint">No image available.</div>`
              }
            </div>

            <div class="tile-actions">
              <div class="mini">Selected: ${it.chosen_print_id ? 'Alt art' : 'Default'}</div>
              <div class="btn-row">
                <button class="btn ghost solid-ghost-btn" type="button" data-action="art" data-oracle="${esc(it.oracle_id)}">Swap Art</button>
              </div>
            </div>
          </article>
        `;
      }).join('');
    }

    function openArtModalFor(oracleId) {
      MODAL_ORACLE = oracleId;
      const it = ITEMS.find(x => x.oracle_id === oracleId);
      els.artTitle.textContent = it ? `Choose Art — ${it.name}` : 'Choose Art';
      els.artSub.textContent = 'Click an image to select.';
      els.artBody.innerHTML = `<div class="inline-hint">Loading prints…</div>`;
      els.artBackdrop.style.display = 'flex';

      fetchPrintsForOracle(oracleId).then(prints => {
        const currentPrintId = it?.chosen_print_id || null;

        if (!prints.length) {
          els.artBody.innerHTML = `<div class="inline-hint">No alternate prints found.</div>`;
          return;
        }

        els.artBody.innerHTML = prints.map(p => {
          const ui = UI_IMG(p);
          const set = p?.set_name || p?.set || '';
          const cn = p?.collector_number || '';
          const selected = (currentPrintId && p.id === currentPrintId) ? 'selected' : '';
          return `
            <div class="print-tile ${selected}" data-print-id="${esc(p.id)}">
              ${ui ? `<img loading="lazy" src="${esc(ui)}" alt="${esc(p.name)}">` : `<div class="inline-hint">No image</div>`}
              <div class="print-cap">${esc(set)} · ${esc(cn)}</div>
            </div>
          `;
        }).join('');
      }).catch(() => {
        els.artBody.innerHTML = `<div class="inline-hint">Failed to load prints.</div>`;
      });
    }

    function closeArtModal() {
      MODAL_ORACLE = null;
      els.artBackdrop.style.display = 'none';
      els.artBody.innerHTML = '';
    }

    function applySelectedPrint(oracleId, printId) {
      const it = ITEMS.find(x => x.oracle_id === oracleId);
      const p = PRINT_CACHE.get(printId);
      if (!it || !p) return;

      it.chosen_print_id = printId;
      it.chosen_img_ui = UI_IMG(p);
      it.chosen_img_print = PRINT_IMG(p);
      renderCards();
    }

    // ---------- Print layout ----------
    function layoutSpec(value) {
      const A4 = { w: 210, h: 297 };
      const LETTER = { w: 215.9, h: 279.4 };
      switch (value) {
        case 'LETTER_3x4': return { page: LETTER, cols: 3, rows: 4 };
        case 'A4_3x3':     return { page: A4, cols: 3, rows: 3 };
        case 'A4_3x4':     return { page: A4, cols: 3, rows: 4 };
        case 'LETTER_3x3':
        default:           return { page: LETTER, cols: 3, rows: 3 };
      }
    }

    function buildExpandedItems() {
      const expanded = [];
      for (const it of ITEMS) {
        for (let i = 0; i < (it.qty || 1); i++) expanded.push(it);
      }
      return expanded;
    }

    function getPrintUrl(it) {
      if (it?.chosen_img_print) return it.chosen_img_print;
      const c = ORACLE_TO_CARD.get(it.oracle_id);
      return PRINT_IMG(c) || '';
    }

    async function waitForPrintImages(root) {
      const imgs = [...root.querySelectorAll('img')];
      const decodePromises = imgs.map(img => {
        // If already loaded
        if (img.complete && img.naturalWidth > 0) return Promise.resolve();

        // Prefer decode() when available
        if (typeof img.decode === 'function') {
          return img.decode().catch(() => new Promise((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = () => reject(new Error('img.onerror'));
          }));
        }

        return new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = () => reject(new Error('img.onerror'));
        });
      });

      const results = await Promise.allSettled(decodePromises);
      const failed = results.filter(r => r.status === 'rejected').length;
      return { total: imgs.length, failed };
    }

    function setPrintCssVars(layout, gapMm, scalePct) {
      const scale = clamp(scalePct, 50, 140) / 100;
      const cardWmm = 63 * scale;
      const cardHmm = 88 * scale;

      els.printRoot.style.setProperty('--page-w-mm', String(layout.page.w));
      els.printRoot.style.setProperty('--page-h-mm', String(layout.page.h));
      els.printRoot.style.setProperty('--cols', String(layout.cols));
      els.printRoot.style.setProperty('--rows', String(layout.rows));
      els.printRoot.style.setProperty('--gap-mm', String(gapMm));
      els.printRoot.style.setProperty('--card-w-mm', String(cardWmm));
      els.printRoot.style.setProperty('--card-h-mm', String(cardHmm));
    }

    function buildPrintDom() {
      const layout = layoutSpec(els.layout.value);

      const scalePct = clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140);
      const gapMm = (isFinite(parseFloat(els.gapMm.value)) ? parseFloat(els.gapMm.value) : 3);

      setPrintCssVars(layout, gapMm, scalePct);

      const expanded = buildExpandedItems();
      if (!expanded.length) throw new Error('No cards to print.');

      const perPage = layout.cols * layout.rows;
      const pagesCount = Math.ceil(expanded.length / perPage);

      const frag = document.createDocumentFragment();

      for (let pi = 0; pi < pagesCount; pi++) {
        const pageEl = document.createElement('section');
        pageEl.className = 'print-page';

        const grid = document.createElement('div');
        grid.className = 'print-grid';

        const slice = expanded.slice(pi * perPage, (pi + 1) * perPage);
        for (const it of slice) {
          const cell = document.createElement('div');
          cell.className = 'print-cell';

          const url = getPrintUrl(it);
          if (url) {
            const img = document.createElement('img');
            img.src = url;
            img.alt = it.name || 'Card';
            img.loading = 'eager';
            cell.appendChild(img);
          }

          grid.appendChild(cell);
        }

        pageEl.appendChild(grid);
        frag.appendChild(pageEl);
      }

      els.printRoot.innerHTML = '';
      els.printRoot.appendChild(frag);
    }

    async function printToPdfViaBrowser() {
      els.spinner.hidden = false;
      setStatus('');
      try {
        buildPrintDom();

        // Make sure images actually decode before opening print dialog
        const { total, failed } = await waitForPrintImages(els.printRoot);
        if (failed) {
          setStatus(`Some images failed to load for printing.\nLoaded: ${total - failed}/${total}\nTry again or switch to a different image size (large vs normal).`);
        }

        // Cleanup after printing
        const cleanup = () => {
          window.removeEventListener('afterprint', cleanup);
          els.printRoot.innerHTML = '';
        };
        window.addEventListener('afterprint', cleanup);

        window.print();
      } catch (e) {
        console.error(e);
        setStatus(`ERROR: ${e?.message || e}`);
      } finally {
        els.spinner.hidden = true;
      }
    }

    // ---------- Load flow ----------
    async function load() {
        els.spinner.hidden = false;
        setStatus('');
        try {
            const itemsRaw = parseDeckText(els.input.value);

            if (!itemsRaw.length) {
            ITEMS = [];
            ORACLE_TO_CARD.clear();
            renderCards();
            return;
            }

            // 1) Resolve exact prints for any lines that specify (SET) CN
            // We'll build:
            // - exactPrintByLineKey: nameLower|setLower|cn -> scryfall card print
            // - nameFallbackList: names to resolve via collection
            const exactPrintByLineKey = new Map();
            const nameFallbackCounts = new Map(); // nameLower -> qty aggregate (for lines without exact print)

            for (const it of itemsRaw) {
            const nm = String(it.name || '').trim();
            if (!nm) continue;

            if (it.setCode && it.collectorNumber) {
                // Resolve exact print now
                const print = await fetchCardBySetAndNumber(it.setCode, it.collectorNumber);
                if (print?.id && print?.oracle_id) {
                const k = `${nm.toLowerCase()}|${String(it.setCode).toLowerCase()}|${String(it.collectorNumber).toLowerCase()}`;
                exactPrintByLineKey.set(k, { print, qty: it.qty || 1, name: nm });
                // Also store canonical oracle card for later
                ORACLE_TO_CARD.set(print.oracle_id, print); // ok to overwrite with a print; we want oracle mapping anyway
                continue;
                }
                // If exact print lookup fails, fall back to name
            }

            nameFallbackCounts.set(nm, (nameFallbackCounts.get(nm) || 0) + (it.qty || 1));
            }

            // 2) Resolve remaining names via collection (your existing behavior)
            const fallbackNames = [...nameFallbackCounts.keys()];
            const cards = fallbackNames.length ? await fetchCollectionByNames(fallbackNames) : [];

            ORACLE_TO_CARD.clear();
            const nameToOracle = new Map();
            for (const c of cards) {
            if (c?.name && c?.oracle_id) {
                nameToOracle.set(String(c.name).toLowerCase(), c.oracle_id);
                ORACLE_TO_CARD.set(c.oracle_id, c);
            }
            }

            // 3) Build oracleCounts AND track preferred print selection per oracle_id
            const oracleCounts = new Map();            // oracle_id -> qty total
            const oracleDisplayName = new Map();       // oracle_id -> display name
            const oraclePreferredPrint = new Map();    // oracle_id -> { printId, ui, printUrl }

            // 3a) Apply exact-print lines first (these should win the default art)
            for (const [k, v] of exactPrintByLineKey.entries()) {
            const { print, qty, name } = v;
            const oracleId = print.oracle_id;

            oracleCounts.set(oracleId, (oracleCounts.get(oracleId) || 0) + qty);
            oracleDisplayName.set(oracleId, name || print.name);

            // If multiple exact-print lines for the same oracle_id exist, last one wins;
            // you could also decide "first wins" if you prefer.
            oraclePreferredPrint.set(oracleId, {
                printId: print.id,
                ui: UI_IMG(print),
                printUrl: PRINT_IMG(print)
            });

            // Keep a canonical oracle card entry
            if (!ORACLE_TO_CARD.has(oracleId)) ORACLE_TO_CARD.set(oracleId, print);
            }

            // 3b) Apply fallback-by-name lines
            for (const [rawName, qty] of nameFallbackCounts.entries()) {
            const key = String(rawName || '').toLowerCase();
            let oracleId = nameToOracle.get(key);

            if (!oracleId) {
                const found = cards.find(c => String(c?.name || '').toLowerCase() === key);
                oracleId = found?.oracle_id;
                if (oracleId && found) {
                ORACLE_TO_CARD.set(oracleId, found);
                oracleDisplayName.set(oracleId, found.name);
                }
            }
            if (!oracleId) continue;

            oracleCounts.set(oracleId, (oracleCounts.get(oracleId) || 0) + qty);
            const c = ORACLE_TO_CARD.get(oracleId);
            if (c?.name && !oracleDisplayName.has(oracleId)) oracleDisplayName.set(oracleId, c.name);
            }

            // 4) Build ITEMS, preselecting art where we have an exact print
            ITEMS = [...oracleCounts.entries()].map(([oracleId, qty]) => {
            const c = ORACLE_TO_CARD.get(oracleId);
            const pref = oraclePreferredPrint.get(oracleId);

            return {
                oracle_id: oracleId,
                name: oracleDisplayName.get(oracleId) || c?.name || 'Unknown',
                qty,

                chosen_print_id: pref?.printId || null,
                chosen_img_ui: pref?.ui || null,
                chosen_img_print: pref?.printUrl || null
            };
            }).sort((a,b) => a.name.localeCompare(b.name));

            renderCards();
            setStatus(`Loaded ${ITEMS.length} unique cards. Prints preselected where provided.`);
        } catch (e) {
            console.error(e);
            setStatus(`ERROR: ${e?.message || e}`);
        } finally {
            els.spinner.hidden = true;
        }
        }

    // ---------- Events ----------
    document.addEventListener('DOMContentLoaded', () => {
      els.gapMm.value = '3';
      els.layout.value = 'LETTER_3x3';

      els.loadBtn.addEventListener('click', load);

      els.clearBtn.addEventListener('click', () => {
        els.input.value = '';
        els.cards.innerHTML = '';
        els.empty.hidden = false;
        setStatus('');
        ITEMS = [];
        ORACLE_TO_CARD.clear();
        ORACLE_TO_PRINTS.clear();
        PRINT_CACHE.clear();
        els.printRoot.innerHTML = '';
      });

      els.scaleDown.addEventListener('click', () => {
        els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) - 1, 50, 140));
      });
      els.scaleUp.addEventListener('click', () => {
        els.scalePct.value = String(clamp((parseInt(els.scalePct.value, 10) || 100) + 1, 50, 140));
      });
      els.scalePct.addEventListener('change', () => {
        els.scalePct.value = String(clamp(parseInt(els.scalePct.value, 10) || 100, 50, 140));
      });

      // Print now uses browser print → Save as PDF
      els.printBtn.addEventListener('click', printToPdfViaBrowser);

      els.cards.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-action="art"]');
        if (!btn) return;
        const oracleId = btn.getAttribute('data-oracle');
        if (!oracleId) return;
        openArtModalFor(oracleId);
      });

      els.artClose.addEventListener('click', closeArtModal);
      els.artBackdrop.addEventListener('click', (e) => {
        if (e.target === els.artBackdrop) closeArtModal();
      });

      els.artBody.addEventListener('click', (e) => {
        const tile = e.target.closest('.print-tile');
        if (!tile || !MODAL_ORACLE) return;

        const pid = tile.getAttribute('data-print-id');
        if (!pid) return;

        els.artBody.querySelectorAll('.print-tile.selected').forEach(n => n.classList.remove('selected'));
        tile.classList.add('selected');

        applySelectedPrint(MODAL_ORACLE, pid);
      });
    });
  </script>

  <!-- Background video logic -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
      const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
      const allowVideo = isFast && isWifiLike;

      const wrap = document.getElementById('bgVideo');
      const vid  = document.getElementById('bgVideoEl');
      if (!wrap || !vid) return;

      if (!allowVideo) { wrap.style.display = 'none'; return; }

      vid.src = '/assets/Blackhole_Animtation.mp4';
      const onReady = () => {
        wrap.classList.add('ready');
        const p = vid.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
      };
      vid.addEventListener('canplay', onReady, { once: true });
      vid.addEventListener('loadeddata', onReady, { once: true });
      vid.addEventListener('loadedmetadata', () => { wrap.classList.add('ready'); }, { once: true });
    });
  </script>

  <!-- Partials loader -->
  <script>
    (async () => {
      try {
        async function loadPartial(url) {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) return null;
          const html = await res.text();
          const tpl = document.createElement('template');
          tpl.innerHTML = html.trim();
          tpl.content.querySelectorAll('style').forEach(st => {
            document.head.appendChild(st.cloneNode(true));
            st.remove();
          });
          return tpl.content.firstElementChild || null;
        }

        const header = document.getElementById('site-header');
        const navEl = await loadPartial('/partials/nav.html');
        if (header && navEl) {
          header.innerHTML = '';
          header.appendChild(navEl);
          initNav(header);
        }

        const discordEl = await loadPartial('/partials/discord.html');
        if (discordEl) document.body.appendChild(discordEl);

        const footerEl = await loadPartial('/partials/footer.html');
        if (footerEl) document.body.appendChild(footerEl);

        function initNav(scope) {
          const btn = scope.querySelector('.menu-toggle');
          const panel = scope.querySelector('#nav-panel');
          if (btn && panel) {
            btn.addEventListener('click', () => {
              const open = panel.classList.toggle('open');
              btn.setAttribute('aria-expanded', open ? 'true' : 'false');
            });
          }
          const here = location.pathname.toLowerCase().replace(/\/+$/, '');
          scope.querySelectorAll('.nav-link').forEach(a => {
            let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
            if (href === '/blog/') href = '/blog';
            if (here === href || ((here === '' || here === '/') && href === '/index.html')) {
              a.setAttribute('aria-current', 'page');
            }
            if (here.includes('/projects')) a.setAttribute('aria-current', 'page');
            if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
          });
        }
      } catch (e) {
        console.warn('Partial load failed:', e);
      }
    })();
  </script>
</body>
</html>
