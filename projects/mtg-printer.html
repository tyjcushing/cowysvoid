<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Print Sheet Builder — Cowy’s Void</title>
  <meta name="description" content="Paste card names, pick arts, export a print-ready PDF." />
  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <link rel="stylesheet" href="/assets/css/void.css">

  <style>
    .controls-row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:10px; }
    .controls-row .control { display:flex; gap:8px; align-items:center; }
    .inline-hint code { font-size: .95em; }

    .btn-group { display:flex; gap:10px; align-items:center; }

    /* Your request: picklist = white text, black bg */
    .select {
      appearance: none;
      background: #000;
      color: #fff;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 12px;
      padding: 10px 12px;
      line-height: 1;
      font: inherit;
    }
    .select:focus { outline: 2px solid rgba(255,255,255,.22); outline-offset: 2px; }

    .card-list {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .card-tile {
      display:flex;
      gap:12px;
      align-items:flex-start;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      backdrop-filter: blur(6px);
    }

    .thumb {
      width: 96px;
      height: auto;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      flex: 0 0 auto;
    }

    .tile-meta { min-width: 0; flex: 1 1 auto; }
    .tile-meta .name { font-weight: 750; }
    .tile-meta .sub { color: var(--muted); font-size: 0.95rem; margin-top: 2px; }
    .tile-actions { margin-top: 10px; display:flex; gap:10px; flex-wrap:wrap; }

    .status {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      white-space: pre-wrap;
    }

    .empty { padding: 18px 14px; border-radius: 16px; border: 1px dashed rgba(255,255,255,.18); color: var(--muted); margin-top: 12px; }

    .spinner { display:inline-flex; align-items:center; gap:8px; color: var(--muted); }
    .spin-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--accent);
      display:inline-block;
      animation: pulse 1s infinite ease-in-out;
    }
    @keyframes pulse { 0%,100%{ transform: scale(.8); opacity:.6 } 50%{ transform: scale(1.2); opacity:1 } }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      background: rgba(0,0,0,.65);
      padding: 16px;
    }
    .modal-backdrop.open { display:flex; }

    .modal {
      width: min(980px, 100%);
      max-height: min(86vh, 860px);
      overflow: hidden;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.82);
      backdrop-filter: blur(10px);
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      display:flex;
      flex-direction: column;
    }

    .modal-head {
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      position: sticky;
      top: 0;
      background: rgba(0,0,0,.86);
      z-index: 2;
    }
    .modal-title { font-weight: 750; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    .modal-body {
      padding: 12px;
      overflow: auto;
    }

    .print-grid {
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      gap: 10px;
    }

    .print-tile {
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      padding: 8px;
      cursor: pointer;
      transition: transform .08s ease, border-color .08s ease, box-shadow .08s ease;
      user-select: none;
    }
    .print-tile:hover { transform: translateY(-1px); }
    .print-tile.selected {
      border-color: rgba(255,255,255,.90);
      box-shadow: 0 0 0 2px rgba(255,255,255,.18) inset, 0 10px 24px rgba(0,0,0,.35);
    }
    .print-tile img {
      width: 100%;
      height: auto;
      border-radius: 10px;
      display:block;
    }
    .print-tile .cap {
      margin-top: 6px;
      color: var(--muted);
      font-size: 12px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
  </style>
</head>

<body>
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <div class="app-layer">
    <header id="site-header" aria-label="Primary"></header>

    <main class="container">
      <section class="panel page-panel solid-surface">
        <header class="page">
          <h1>Print Sheet Builder</h1>
          <p class="sub">
            Paste card names (qty optional). Choose alternate arts per card, then click <strong>Print</strong> to generate a clean, print-ready <strong>PDF</strong>.
          </p>
        </header>

        <div class="toolbar toolbar-wide" role="region" aria-label="Paste cards">
          <label class="input input-solid solid-input" style="align-items:start">
            <textarea id="cardInput" class="textarea" placeholder="Examples:
1 Sol Ring
2x Dark Ritual
Arcane Signet
..."></textarea>
          </label>
        </div>

        <div class="controls-row">
          <button id="loadBtn" class="btn">Load Cards</button>
          <button id="clearBtn" class="btn ghost solid-ghost-btn" type="button">Clear</button>

          <span class="control">
            <label for="gapSel"><strong>Bleed / gap</strong></label>
            <select id="gapSel" class="select">
              <option value="0">No gap (0mm)</option>
              <option value="0.2">0.2mm</option>
              <option value="3">3mm</option>
            </select>
          </span>

          <div class="btn-group">
            <button id="printBtn" class="btn">Print</button>
            <span id="spinner" class="spinner" hidden>
              <span class="spin-dot" aria-hidden="true"></span>
              <span class="inline-hint">Working…</span>
            </span>
          </div>
        </div>

        <div class="inline-hint">
          This loader is <strong>case-insensitive</strong> (uses Scryfall <code>/cards/named?fuzzy=</code> so <code>sol ring</code> works).
        </div>

        <div id="status" class="status" hidden></div>
        <div id="empty" class="empty">Paste some cards and click <strong>Load Cards</strong>.</div>

        <div id="cards" class="card-list" aria-label="Loaded cards"></div>
      </section>
    </main>
  </div>

  <!-- Art Picker Modal -->
  <div id="artBackdrop" class="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="artTitle">
    <div class="modal">
      <div class="modal-head">
        <div id="artTitle" class="modal-title">Choose print</div>
        <button id="artClose" class="btn ghost solid-ghost-btn" type="button">Close</button>
      </div>
      <div id="artBody" class="modal-body">
        <div class="inline-hint">Loading prints…</div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Print Sheet Builder — single-file “full class”
   - Robust load: /cards/named?fuzzy= (case-insensitive)
   - Art swap: oracleid prints search
   - Print: generates a real PDF (no browser headers/footers)
   ========================================================= */

function esc(s) {
  return (s || '').replace(/[&<>\"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

function normalizeName(s = '') {
  return s.normalize('NFKC').trim().replace(/\s+/g, ' ').toLowerCase();
}

function stripNameAnnotations(s = '') {
  s = s.trim();
  const cuts = [s.indexOf('['), s.indexOf('{'), s.indexOf('('), s.indexOf('^^')].filter(i => i >= 0);
  if (!cuts.length) return s;
  return s.slice(0, Math.min(...cuts)).trim();
}

function parseCardText(text) {
  const lines = (text || '').replace(/\r\n?/g, '\n').split('\n');
  const items = [];
  for (let raw of lines) {
    let line = raw.trim();
    if (!line) continue;
    line = line.replace(/\s*\/\/.*$/,'').replace(/\s*#.*$/,'').trim();
    if (!line) continue;

    let m = line.match(/^(\d+)\s*x?\s+(.+)$/i);
    if (m) {
      items.push({ qty: parseInt(m[1], 10), name: stripNameAnnotations(m[2]) });
      continue;
    }
    items.push({ qty: 1, name: stripNameAnnotations(line) });
  }
  return items;
}

function getFrontImage(card) {
  if (card?.image_uris?.normal) return card.image_uris.normal;
  if (Array.isArray(card?.card_faces) && card.card_faces[0]?.image_uris?.normal) return card.card_faces[0].image_uris.normal;
  return null;
}

function mmToPt(mm) { return mm * 72 / 25.4; }

const els = {
  input: document.getElementById('cardInput'),
  loadBtn: document.getElementById('loadBtn'),
  clearBtn: document.getElementById('clearBtn'),
  gapSel: document.getElementById('gapSel'),
  printBtn: document.getElementById('printBtn'),
  cards: document.getElementById('cards'),
  empty: document.getElementById('empty'),
  status: document.getElementById('status'),
  spinner: document.getElementById('spinner'),

  artBackdrop: document.getElementById('artBackdrop'),
  artTitle: document.getElementById('artTitle'),
  artBody: document.getElementById('artBody'),
  artClose: document.getElementById('artClose')
};

function setStatus(msg) {
  els.status.hidden = !msg;
  els.status.textContent = msg || '';
}

let ITEMS = [];           // [{ key, name, qty, card, selectedPrint:{id,img} }]
let PRINT_CACHE = new Map(); // oracleId -> prints[]
let MODAL_KEY = null;

function itemKey(name) { return normalizeName(name); }

/* ----------------------------
   Scryfall: robust card resolve
   Uses /cards/named?fuzzy=
---------------------------- */

async function fetchNamedFuzzy(name) {
  const url = `https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`;
  const r = await fetch(url);
  if (!r.ok) return null;
  return await r.json();
}

async function resolveUniqueCards(names) {
  // limit concurrency so we don’t slam Scryfall
  const uniq = [...new Set(names.map(n => normalizeName(n)))];
  const normToOriginal = new Map();
  for (const n of names) {
    const k = normalizeName(n);
    if (!normToOriginal.has(k)) normToOriginal.set(k, n);
  }

  const out = new Map(); // norm -> card
  const MAX = 6;
  let idx = 0;

  async function worker() {
    while (idx < uniq.length) {
      const i = idx++;
      const norm = uniq[i];
      const original = normToOriginal.get(norm) || norm;
      const card = await fetchNamedFuzzy(original);
      if (card && card.object === 'card') out.set(norm, card);
    }
  }

  const workers = Array.from({ length: Math.min(MAX, uniq.length) }, () => worker());
  await Promise.all(workers);
  return out;
}

/* ----------------------------
   Prints (alt arts)
---------------------------- */

async function fetchPrintsForOracle(oracleId) {
  if (!oracleId) return [];
  if (PRINT_CACHE.has(oracleId)) return PRINT_CACHE.get(oracleId);

  const all = [];
  let url = `https://api.scryfall.com/cards/search?order=released&q=oracleid%3A${encodeURIComponent(oracleId)}&unique=prints`;
  while (url) {
    const r = await fetch(url);
    if (!r.ok) break;
    const j = await r.json();
    (j.data || []).forEach(c => all.push(c));
    url = j.has_more ? j.next_page : null;
  }

  all.sort((a,b) => String(b.released_at || '').localeCompare(String(a.released_at || '')));
  PRINT_CACHE.set(oracleId, all);
  return all;
}

/* ----------------------------
   Render main list
---------------------------- */

function renderCards() {
  const list = ITEMS.map(it => {
    const card = it.card;
    const img = it.selectedPrint?.img || getFrontImage(card);

    return `
      <article class="card-tile">
        <img class="thumb" src="${esc(img || '')}" alt="${esc(it.name)}" loading="lazy" referrerpolicy="no-referrer"
          onerror="this.style.opacity='.3';">
        <div class="tile-meta">
          <div class="name">${esc(it.qty)}× ${esc(it.name)}</div>
          <div class="sub">${card ? esc(card.type_line || '') : 'Not found'}</div>
          <div class="tile-actions">
            <button class="btn ghost solid-ghost-btn" type="button" data-action="art" data-key="${esc(it.key)}">Swap art</button>
          </div>
        </div>
      </article>
    `;
  }).join('');

  els.cards.innerHTML = list;
  els.empty.hidden = ITEMS.length > 0;
}

/* ----------------------------
   Modal
---------------------------- */

async function openArtModalFor(key) {
  const it = ITEMS.find(x => x.key === key);
  if (!it || !it.card) return;

  MODAL_KEY = key;
  els.artTitle.textContent = `Choose print — ${it.name}`;
  els.artBody.innerHTML = `<div class="inline-hint">Loading prints…</div>`;
  els.artBackdrop.classList.add('open');

  try {
    const prints = await fetchPrintsForOracle(it.card.oracle_id);
    if (!prints.length) {
      els.artBody.innerHTML = `<div class="inline-hint">No alternate prints found.</div>`;
      return;
    }

    const selectedId = it.selectedPrint?.id || it.card.id;

    const tiles = prints.map(p => {
      const img = getFrontImage(p);
      const cap = `${String(p.set || '').toUpperCase()} · #${p.collector_number || ''} · ${p.released_at || ''}`;
      const isSel = p.id === selectedId;
      return `
        <div class="print-tile ${isSel ? 'selected' : ''}" role="button" tabindex="0"
             data-print-id="${esc(p.id)}" data-img="${esc(img || '')}">
          <img src="${esc(img || '')}" alt="${esc(p.name)}" loading="lazy" referrerpolicy="no-referrer"
            onerror="this.style.opacity='.3'">
          <div class="cap">${esc(cap)}</div>
        </div>
      `;
    }).join('');

    els.artBody.innerHTML = `<div class="print-grid">${tiles}</div>`;
  } catch (e) {
    console.warn(e);
    els.artBody.innerHTML = `<div class="inline-hint">Failed to load prints.</div>`;
  }
}

function closeArtModal() {
  MODAL_KEY = null;
  els.artBackdrop.classList.remove('open');
}

function applySelectedPrintToItem(key, printId, imgUrl) {
  const it = ITEMS.find(x => x.key === key);
  if (!it) return;
  it.selectedPrint = { id: printId, img: imgUrl };
  renderCards();
}

/* ----------------------------
   PDF generation (pdf-lib)
   This avoids browser headers/footers entirely.
---------------------------- */

async function loadPdfLib() {
  if (window.PDFLib) return true;

  // Load from CDN (works well on Cloudflare Pages, with CSP allowing it)
  const s = document.createElement('script');
  s.src = 'https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js';
  s.async = true;

  const ok = await new Promise(resolve => {
    s.onload = () => resolve(true);
    s.onerror = () => resolve(false);
    document.head.appendChild(s);
  });

  return ok && !!window.PDFLib;
}

async function fetchAsBytes(url) {
  const r = await fetch(url, { mode: 'cors' });
  if (!r.ok) throw new Error('Image fetch failed: ' + r.status);
  return new Uint8Array(await r.arrayBuffer());
}

async function buildPdfBlob() {
  // Letter size in points
  const pageW = 612; // 8.5 * 72
  const pageH = 792; // 11 * 72

  // MTG card size in mm
  const cardWpt = mmToPt(63);
  const cardHpt = mmToPt(88);

  const gapMm = parseFloat(els.gapSel.value || '0');
  const gapPt = mmToPt(gapMm);

  // 3x3 grid per letter
  const cols = 3, rows = 3;
  const perPage = cols * rows;

  const totalW = cols * cardWpt + (cols - 1) * gapPt;
  const totalH = rows * cardHpt + (rows - 1) * gapPt;

  const marginX = (pageW - totalW) / 2;
  const marginY = (pageH - totalH) / 2;

  // Flatten images by qty
  const imgs = [];
  for (const it of ITEMS) {
    if (!it.card) continue;
    const img = it.selectedPrint?.img || getFrontImage(it.card);
    if (!img) continue;
    for (let i = 0; i < (it.qty || 1); i++) imgs.push(img);
  }

  if (!imgs.length) throw new Error('No printable images.');

  const { PDFDocument } = window.PDFLib;
  const pdfDoc = await PDFDocument.create();

  // Basic cache so repeats don’t refetch / re-embed
  const bytesCache = new Map();
  const embedCache = new Map(); // url -> embedded image

  for (let i = 0; i < imgs.length; i += perPage) {
    const page = pdfDoc.addPage([pageW, pageH]);
    const slice = imgs.slice(i, i + perPage);

    for (let n = 0; n < perPage; n++) {
      const url = slice[n];
      if (!url) continue;

      let emb = embedCache.get(url);
      if (!emb) {
        let bytes = bytesCache.get(url);
        if (!bytes) {
          bytes = await fetchAsBytes(url);
          bytesCache.set(url, bytes);
        }

        // Scryfall "normal" is jpg; but just in case:
        const isPng = /\.png(\?|$)/i.test(url);
        emb = isPng ? await pdfDoc.embedPng(bytes) : await pdfDoc.embedJpg(bytes);
        embedCache.set(url, emb);
      }

      const c = n % cols;
      const r = Math.floor(n / cols);

      // pdf-lib origin is bottom-left
      const x = marginX + c * (cardWpt + gapPt);
      const y = pageH - marginY - cardHpt - r * (cardHpt + gapPt);

      page.drawImage(emb, { x, y, width: cardWpt, height: cardHpt });
    }
  }

  const pdfBytes = await pdfDoc.save();
  return new Blob([pdfBytes], { type: 'application/pdf' });
}

async function printPdf() {
  els.spinner.hidden = false;
  setStatus('');

  // Must open tab synchronously to avoid popup blocking
  const w = window.open('', '_blank');
  if (!w) {
    setStatus(
      'Popup blocked.\n' +
      'Allow popups for this site, then click Print again.'
    );
    els.spinner.hidden = true;
    return;
  }

  try {
    const ok = await loadPdfLib();
    if (!ok) {
      w.document.write('<!doctype html><title>PDF error</title><body style="font-family:sans-serif">Failed to load PDF library (pdf-lib). Check CSP/script-src.</body>');
      w.document.close();
      setStatus('Failed to load pdf-lib. If you use CSP, allow https://unpkg.com in script-src.');
      return;
    }

    const blob = await buildPdfBlob();
    const url = URL.createObjectURL(blob);

    // Navigate the already-opened tab to the PDF blob URL
    w.location.replace(url);

    setStatus(
      'PDF generated and opened in a new tab.\n' +
      'Print from that tab (no browser headers/footers are embedded in the PDF).'
    );
  } catch (e) {
    console.warn(e);
    w.document.write('<!doctype html><title>PDF error</title><body style="font-family:sans-serif">PDF generation failed. Check console.</body>');
    w.document.close();
    setStatus('PDF generation failed: ' + (e?.message || String(e)));
  } finally {
    els.spinner.hidden = true;
  }
}

/* ----------------------------
   Load / Clear
---------------------------- */

async function load() {
  els.spinner.hidden = false;
  setStatus('');

  try {
    const parsed = parseCardText(els.input.value);
    if (!parsed.length) {
      ITEMS = [];
      renderCards();
      setStatus('No cards found in input.');
      return;
    }

    // Build items + resolve unique cards via fuzzy
    const temp = parsed.map(it => ({
      key: itemKey(it.name),
      name: it.name,
      qty: it.qty || 1,
      card: null,
      selectedPrint: null
    }));

    const normToCard = await resolveUniqueCards(temp.map(x => x.name));

    for (const it of temp) {
      it.card = normToCard.get(it.key) || null;
    }

    ITEMS = temp;
    renderCards();

    const missing = ITEMS.filter(it => !it.card).map(it => it.name);
    if (missing.length) {
      setStatus(
        `Loaded ${ITEMS.length} line item(s).\n` +
        `Not found (${missing.length}):\n- ${missing.slice(0, 14).join('\n- ')}${missing.length > 14 ? `\n… +${missing.length - 14} more` : ''}`
      );
    } else {
      setStatus(`Loaded ${ITEMS.length} line item(s).`);
    }
  } catch (e) {
    console.warn(e);
    setStatus('Load failed. Check console for details.');
  } finally {
    els.spinner.hidden = true;
  }
}

function clearAll() {
  els.input.value = '';
  els.cards.innerHTML = '';
  els.empty.hidden = false;
  setStatus('');
  ITEMS = [];
  PRINT_CACHE.clear();
}

/* ----------------------------
   Events
---------------------------- */

document.addEventListener('DOMContentLoaded', () => {
  els.loadBtn.addEventListener('click', load);
  els.clearBtn.addEventListener('click', clearAll);

  els.printBtn.addEventListener('click', () => {
    if (!ITEMS.length) {
      setStatus('No cards loaded. Click "Load Cards" first.');
      return;
    }
    printPdf();
  });

  els.cards.addEventListener('click', (e) => {
    const btn = e.target.closest('button[data-action="art"]');
    if (!btn) return;
    openArtModalFor(btn.getAttribute('data-key'));
  });

  els.artClose.addEventListener('click', closeArtModal);
  els.artBackdrop.addEventListener('click', (e) => {
    if (e.target === els.artBackdrop) closeArtModal();
  });

  els.artBody.addEventListener('click', (e) => {
    const tile = e.target.closest('.print-tile');
    if (!tile || !MODAL_KEY) return;

    // show selected border
    els.artBody.querySelectorAll('.print-tile.selected').forEach(n => n.classList.remove('selected'));
    tile.classList.add('selected');

    // apply art
    applySelectedPrintToItem(
      MODAL_KEY,
      tile.getAttribute('data-print-id'),
      tile.getAttribute('data-img')
    );
  });

  els.artBody.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter' && e.key !== ' ') return;
    const tile = e.target.closest('.print-tile');
    if (!tile || !MODAL_KEY) return;
    e.preventDefault();
    tile.click();
  });
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
  const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
  const allowVideo = isFast && isWifiLike;

  const wrap = document.getElementById('bgVideo');
  const vid  = document.getElementById('bgVideoEl');
  if (!wrap || !vid) return;

  if (!allowVideo) {
    wrap.style.display = 'none';
    return;
  }

  vid.src = '/assets/Blackhole_Animtation.mp4';

  const onReady = () => {
    wrap.classList.add('ready');
    const p = vid.play();
    if (p && typeof p.catch === 'function') p.catch(() => {});
  };

  vid.addEventListener('canplay', onReady, { once: true });
  vid.addEventListener('loadeddata', onReady, { once: true });
  vid.addEventListener('loadedmetadata', () => {
    wrap.classList.add('ready');
  }, { once: true });
});
</script>

<script>
(async () => {
  try {
    async function loadPartial(url) {
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) return null;
      const html = await res.text();
      const tpl = document.createElement('template');
      tpl.innerHTML = html.trim();
      tpl.content.querySelectorAll('style').forEach(st => {
        document.head.appendChild(st.cloneNode(true));
        st.remove();
      });
      return tpl.content.firstElementChild || null;
    }

    const header = document.getElementById('site-header');
    const navEl = await loadPartial('/partials/nav.html');
    if (header && navEl) {
      header.innerHTML = '';
      header.appendChild(navEl);
      initNav(header);
    }

    const discordEl = await loadPartial('/partials/discord.html');
    if (discordEl) document.body.appendChild(discordEl);

    const footerEl = await loadPartial('/partials/footer.html');
    if (footerEl) document.body.appendChild(footerEl);

    function initNav(scope) {
      const btn = scope.querySelector('.menu-toggle');
      const panel = scope.querySelector('#nav-panel');
      if (btn && panel) {
        btn.addEventListener('click', () => {
          const open = panel.classList.toggle('open');
          btn.setAttribute('aria-expanded', open ? 'true' : 'false');
        });
      }
      const here = location.pathname.toLowerCase().replace(/\/+$/, '');
      scope.querySelectorAll('.nav-link').forEach(a => {
        let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
        if (href === '/blog/') href = '/blog';
        if (here === href || ((here === '' || here === '/') && href === '/index.html')) {
          a.setAttribute('aria-current', 'page');
        }
        if (here.includes('/projects')) a.setAttribute('aria-current', 'page');
        if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
      });
    }
  } catch (e) {
    console.warn('Partial load failed:', e);
  }
})();
</script>
</body>
</html>
