<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MTG — Cowy’s Void</title>
  <meta name="description" content="Magic: The Gathering hub — deck library with Scryfall-powered art, colors, and smart search." />
  <link rel="icon" href="/assets/icons/favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="/assets/icons/BlackHole.png" sizes="32x32">
  <style>
    :root{ --bg:#090a12; --card:#0b0f17; --text:#e8eaff; --muted:#9aa4c7; --accent:#6aa7ff; --accent-2:#b388ff; --ring:rgba(130,160,255,.35) }
    @media (prefers-color-scheme: light){ :root{ --bg:#f6f7ff; --card:#ffffff; --text:#0b0d10; --muted:#5e6b85; --accent:#3d6cff; --accent-2:#7f68ff; --ring:rgba(61,108,255,.25) } }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    a{color:inherit;text-decoration:none}
    .container{max-width:1080px;margin:0 auto;padding:24px}

    header.page h1{margin:6px 0 6px;font-weight:900;letter-spacing:-.015em;font-size:clamp(28px,3.8vmin,44px)}
    header.page p{margin:0;color:var(--muted)}

    .toolbar{display:flex;flex-wrap:wrap;gap:10px;margin:16px 0}
    .input{flex:1 1 260px;display:flex;align-items:center;gap:8px;padding:10px 12px;border-radius:12px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08)}
    .input input{all:unset;flex:1}
    .btn{padding:10px 14px;border-radius:12px;background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#0b0d10;font-weight:700;cursor:pointer}
    .btn.ghost{background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);color:var(--text)}

    .filters{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    .chip{font-size:12px;color:var(--muted);border:1px solid rgba(255,255,255,.08);padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.03);cursor:pointer}
    .chip.active{color:var(--text);border-color:var(--ring);box-shadow:0 0 0 3px var(--ring)}

    .section{margin:18px 0 8px}
    .section h2{margin:0 0 6px;font-size:18px;color:var(--text)}
    .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:16px;margin-top:12px}

    /* === Background video layer (behind everything) === */
    .bg-video { position: fixed; inset: 0; z-index: 0; overflow: hidden; pointer-events: none; }
    .bg-video video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity .6s ease; }
    .bg-video.ready video { opacity: 0.35; }
    .bg-video::after { content: ""; position: absolute; inset: 0; background: radial-gradient(120% 120% at 50% 35%, rgba(0,0,0,.2), rgba(0,0,0,.55)); pointer-events: none; }

    /* Card layout */
    .card{
      grid-column:span 6;
      background:var(--card);
      border:1px solid rgba(255,255,255,.06);
      border-radius:18px;
      padding:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      display:grid;
      grid-template-columns:140px 1fr;
      gap:16px;
      align-items:start;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
    }
    .card:hover{ transform: translateY(-2px); border-color: var(--ring); box-shadow:0 14px 36px rgba(0,0,0,.30) }
    @media (max-width:900px){ .card{grid-column:span 12} }
    @media (max-width:640px){ .card{grid-template-columns:1fr} }

    .title-row{display:flex;align-items:flex-start;gap:10px;justify-content:space-between}
    .card h3{margin:0;font-size:18px;line-height:1.1}
    .card h3 .subtitle{display:block;font-weight:600;color:var(--muted);font-size:12px;margin-top:3px}

    .notes{color:var(--muted);font-size:14px;margin:8px 0 10px}
    .stats{display:flex;gap:10px;flex-wrap:wrap;color:var(--muted);font-size:12px}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.10);font-size:12px;color:var(--text)}
    .tags{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    .tag{font-size:12px;color:var(--muted);border:1px solid rgba(255,255,255,.08);padding:4px 8px;border-radius:999px;background:rgba(255,255,255,.03)}

    /* Commander image(s) */
    .thumbwrap{
      position:relative;width:100%;aspect-ratio:3/4;border-radius:14px;overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background:linear-gradient(135deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      box-shadow:0 6px 18px rgba(0,0,0,.25)
    }
    .thumbwrap.grid2{display:grid;grid-template-columns:1fr 1fr}
    .thumb{width:100%;height:100%;object-fit:cover}

    /* Mana symbols (Scryfall) */
    .pips{display:flex;gap:6px;align-items:center}
    .ms{width:18px;height:18px;display:inline-block;vertical-align:middle}

    .empty{color:var(--muted);padding:24px;border:1px dashed rgba(255,255,255,.12);border-radius:12px;text-align:center}
  </style>
</head>
<body>
  <!-- Background video container (kept behind via z-index:0 so it isn't hidden by the body background) -->
  <div id="bgVideo" class="bg-video" aria-hidden="true">
    <video id="bgVideoEl" playsinline muted autoplay loop preload="metadata" poster="/assets/Blackhole_Poster.jpg"></video>
  </div>

  <header id="site-header" aria-label="Primary"></header>

  <main class="container">
    <header class="page">
      <h1>Magic: The Gathering</h1>
      <p>Deck library with search, tags, commander art, and official mana symbols.</p>
    </header>

    <div class="toolbar" role="search">
      <label class="input" aria-label="Search decks">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M21 21l-4.35-4.35m1.35-5.65A7 7 0 1 1 5 5a7 7 0 0 1 13 0z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
        <input id="q" placeholder="Search by title, tags, color, etc." />
      </label>
      <button id="clearBtn" class="btn ghost" type="button">Clear</button>
    </div>

    <div class="filters" id="tagFilters" aria-label="Tag filters"></div>

    <div class="section"><h2>All Decks</h2></div>
    <section id="deckGrid" class="grid" aria-live="polite"></section>
    <div id="empty" class="empty" hidden>No decks match your search.</div>
  </main>

  <!-- === Scryfall helpers (with MDFC face control) === -->
  <script>
  const DEBUG = false;
  const log = (...a) => DEBUG && console.log('[MTG]', ...a);
  const warn = (...a) => DEBUG && console.warn('[MTG]', ...a);

  // Scryfall mana SVGs
  const MANA_SVG = l => `https://svgs.scryfall.io/card-symbols/${l.toUpperCase()}.svg`;
  function renderManaSymbols(colors){
    if (!Array.isArray(colors) || !colors.length) return '';
    const uniq = [...new Set(colors.map(c=>c.toUpperCase()))];
    return `<span class="pips">${uniq.map(c => `<img class="ms" src="${MANA_SVG(c)}" alt="${c}">`).join('')}</span>`;
  }

  // ---- Robust Scryfall fetch (single + double-faced) ----
  const _cardCache = new Map();

  function pickImage(imgs){
    return imgs?.art_crop || imgs?.normal || imgs?.large || imgs?.png || null;
  }
  function normalizeColorsFromFaces(faces){
    const set = new Set();
    (faces || []).forEach(f => {
      const arr = f.color_identity || f.colors || f.colorIndicator || [];
      (arr || []).forEach(c => set.add(c));
    });
    return [...set];
  }
  async function fetchJson(url){
    const r = await fetch(url, { cache: 'force-cache' });
    if (!r.ok) return null;
    return r.json();
  }

  /**
   * getScryfallCard(name, { face: 'front'|'back', faceIndex?: 0|1 })
   * Returns { image, colors, raw }
   */
  async function getScryfallCard(name, opts = {}){
    if (!name) return null;
    const cacheKey = `${name}::${opts.face ?? ''}::${Number.isInteger(opts.faceIndex)?opts.faceIndex:''}`;
    if (_cardCache.has(cacheKey)) return _cardCache.get(cacheKey);

    let j = await fetchJson(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(name)}`);
    if (!j) j = await fetchJson(`https://api.scryfall.com/cards/named?fuzzy=${encodeURIComponent(name)}`);
    if (!j) { warn('Scryfall not found for', name); return null; }

    let image = null;
    let colors = Array.isArray(j.color_identity) ? j.color_identity.slice() : [];

    if (j.image_uris) {
      image = pickImage(j.image_uris);
    } else if (Array.isArray(j.card_faces) && j.card_faces.length) {
      const faces = j.card_faces;
      let idx = 0;

      if (Number.isInteger(opts.faceIndex)) {
        idx = Math.max(0, Math.min(faces.length - 1, opts.faceIndex));
      } else if (opts.face === 'back') {
        idx = Math.min(1, faces.length - 1);
      } else if (opts.face === 'front') {
        idx = 0;
      } else {
        // default: try match left side of "A // B"
        const left = String(name).split('//')[0].trim().toLowerCase();
        const m = faces.findIndex(f => (f.name || '').toLowerCase() === left);
        idx = m >= 0 ? m : 0;
      }

      const face = faces[idx] || faces[0];
      image = pickImage(face.image_uris || {});
      if (!colors.length) colors = normalizeColorsFromFaces(faces);
    }

    const out = { image, colors, raw: j };
    _cardCache.set(cacheKey, out);
    return out;
  }

  // Union color identity for 1+ commanders (works with MDFC + partners)
  async function unionColorsFromCommanders(cmds){
    const set = new Set();
    for (const c of cmds || []) {
      const name = typeof c === 'string' ? c : c?.name;
      const face = typeof c === 'object' ? c?.face : undefined;
      const faceIndex = typeof c === 'object' ? c?.faceIndex : undefined;
      const card = await getScryfallCard(name, { face, faceIndex });
      (card?.colors || []).forEach(x => set.add(x));
    }
    return [...set];
  }
  </script>

  <!-- === Data + UI === -->
  <script>
  // Expect /data/decks.json entries like:
  // { id, title, archidektUrl?, commanders:[ "Name" | {name, face?, faceIndex?} ], tags?, bracket?, notes?, updated? }
  const state = { all: [], filtered: [], activeTags: new Set() };

  function esc(s){return (s||'').replace(/[&<>\"']/g, m=>({"&":"&amp;","<":"&lt;","&gt;":"&gt;","\"":"&quot;","'":"&#39;"}[m]))}

  async function loadDecks(){
    const res = await fetch('/data/decks.json', { cache: 'no-store' });
    if(!res.ok) throw new Error('Failed to load decks.json');
    state.all = (await res.json()) || [];

    // Normalize and prebuild
    state.all.forEach((d, i) => {
      d._idx = i; // stable tie-break
      if (!Array.isArray(d.commanders)) d.commanders = [];
      // Normalize commanders to objects with {name, face?, faceIndex?}
      d._cmds = d.commanders.map(c => typeof c === 'string' ? ({ name: c }) : ({
        name: c?.name || '',
        face: c?.face,
        faceIndex: Number.isInteger(c?.faceIndex) ? c.faceIndex : undefined
      })).filter(c => c.name);

      if (!d.archidektUrl && d.id) d.archidektUrl = `https://archidekt.com/decks/${d.id}`;
    });

    // Enrich with Scryfall
    await enrichFromScryfall(state.all);

    // Default sort: updated desc, then title
    state.all.sort((a,b)=>{
      const ad = new Date(a.updated||0).getTime(), bd = new Date(b.updated||0).getTime();
      if (bd - ad) return bd - ad;
      return (a.title||'').localeCompare(b.title||'');
    });

    state.filtered = state.all.slice();
    buildTagChips();
    render();
  }

  async function enrichFromScryfall(items){
    const limit = 3; // polite concurrency
    const queue = items.slice();
    const workers = Array.from({length: limit}, () => worker());
    await Promise.all(workers);

    async function worker(){
      while(queue.length){
        const d = queue.shift();
        try {
          // Commander images (up to two), honoring MDFC face hints
          const imgs = [];
          const colorSet = new Set();
          for (const c of d._cmds) {
            const card = await getScryfallCard(c.name, { face: c.face, faceIndex: c.faceIndex });
            if (card?.image) imgs.push(card.image);
            (card?.colors || []).forEach(x => colorSet.add(x));
          }
          d.commanderImages = imgs.slice(0, 2);
          d.commanderImage  = imgs[0] || d.commanderImage;

          // Colors (union)
          if (colorSet.size) d.colors = [...colorSet];
        } catch(e){
          console.warn('Scryfall enrich failed for', d.title || d.id, e);
        }
      }
    }
  }

  /* ---------- Search ---------- */

  const COLOR_WORDS = {
    white:'W', w:'W',
    blue:'U',  u:'U',
    black:'B', b:'B',
    red:'R',   r:'R',
    green:'G', g:'G',
    colorless:'C', c:'C'
  };

  function parseQuery(raw){
    const q = (raw||'').trim();
    const out = { text:'', colorSet:new Set(), usedColorOp:false, preferNameSort:false, bracketToken:null, pureDigit:null };
    if (!q) return out;

    let working = q;

    // c:<letters or words> supports commas (e.g., c:wb, c:w,b, c:white,black)
    const colorOp = working.match(/(^|\s)c:([a-z,]+)/i);
    if (colorOp){
      out.usedColorOp = true;
      const payload = colorOp[2].toLowerCase().split(',').map(s=>s.trim()).filter(Boolean);
      for (const token of payload){
        const mapped = COLOR_WORDS[token] || token.toUpperCase();
        for (const ch of mapped.replace(/[^WUBRGC]/g,'')) out.colorSet.add(ch);
      }
      working = working.replace(colorOp[0], '').trim();
    }

    // b:<text> bracket filter (e.g., b:3, b:upgraded)
    const bracketOp = working.match(/(^|\s)b:([^\s]+)/i);
    if (bracketOp){
      out.bracketToken = bracketOp[2];
      working = working.replace(bracketOp[0], '').trim();
      // If query is just a bracket op, prefer name sort
      if (!working) out.preferNameSort = true;
    }

    // Single digit fallback (if user types just "3")
    const digitOnly = working.match(/^([0-9])$/);
    if (digitOnly){
      out.pureDigit = digitOnly[1];
      out.preferNameSort = true;
      working = '';
    }

    // color words/letters if no c:
    if (!out.usedColorOp){
      const tokens = working.toLowerCase().split(/\s+/).filter(Boolean);
      let allColorWords = tokens.length>0; // assume, prove otherwise
      for (const t of tokens){
        if (COLOR_WORDS[t]) out.colorSet.add(COLOR_WORDS[t]);
        else allColorWords = false;
      }
      if (tokens.length && allColorWords){
        // pure color word query => no text filter, name sort
        out.preferNameSort = tokens.length === 1;
        working = '';
      }
    }

    out.text = working.trim();
    return out;
  }

  function matchesColorFilter(deckColors=[], filterSet){
    if (!filterSet || !filterSet.size) return true;
    const dc = new Set((deckColors||[]).map(c=>c.toUpperCase()));
    for (const f of filterSet){ if (!dc.has(f)) return false; }
    return true;
  }

  function templateCard(d){
    const title = esc(d.title || `Deck ${d.id||''}`);
    const url = esc(d.archidektUrl || '');
    const notes = esc(d.notes||'');
    const commanderNames = (d._cmds||[]).map(x=>x.name);
    const shownNames = commanderNames.map(esc);
    const colors = Array.isArray(d.colors)? d.colors : [];
    const bracket = esc(d.bracket||'');
    const tags = Array.isArray(d.tags)? d.tags.map(esc) : [];
    const updated = d.updated ? new Date(d.updated).toLocaleDateString() : '';
    const img1 = d.commanderImages?.[0] ? esc(d.commanderImages[0]) : '';
    const img2 = d.commanderImages?.[1] ? esc(d.commanderImages[1]) : '';

    const imageBlock = (img1 && img2)
      ? `<div class="thumbwrap grid2"><img class="thumb" src="${img1}" alt="Commander: ${shownNames[0]||title}"><img class="thumb" src="${img2}" alt="Commander: ${shownNames[1]||title}"></div>`
      : `<div class="thumbwrap">${img1 ? `<img class="thumb" src="${img1}" alt="Commander: ${shownNames[0]||title}">` : ''}</div>`;

    return `
      <article class="card">
        ${imageBlock}
        <div class="body">
          <div class="title-row">
            <h3>${title}${shownNames.length?`<span class="subtitle">${shownNames.join(' / ')}</span>`:''}</h3>
            ${colors.length?`${renderManaSymbols(colors)}`:''}
          </div>
          ${notes?`<div class="notes">${notes}</div>`:''}
          ${tags.length?`<div class="tags">${tags.map(t=>`<span class="tag">${t}</span>`).join('')}</div>`:''}
          <div class="stats" style="margin-top:10px">
            ${bracket?`<span class="pill">${bracket}</span>`:''}
            ${updated?`<span class="pill">Updated: ${updated}</span>`:''}
            ${url?`<a class="btn" href="${url}" target="_blank" rel="noopener">View on Archidekt</a>`:''}
          </div>
        </div>
      </article>`;
  }

  function buildTagChips(){
    const allTags = new Set();
    state.all.forEach(d => (d.tags||[]).forEach(t => allTags.add(t)));
    const list = document.getElementById('tagFilters');
    list.innerHTML = '';
    [...allTags].sort().forEach(tag => {
      const chip = document.createElement('button');
      chip.type = 'button';
      chip.className = 'chip';
      chip.textContent = tag;
      chip.addEventListener('click', () => {
        if(state.activeTags.has(tag)) state.activeTags.delete(tag); else state.activeTags.add(tag);
        chip.classList.toggle('active');
        applyFilters();
      });
      list.appendChild(chip);
    });
  }

  function render(){
    const grid = document.getElementById('deckGrid');
    if(!state.filtered.length){
      grid.innerHTML = '';
      document.getElementById('empty').hidden = false;
      return;
    }
    document.getElementById('empty').hidden = true;
    grid.innerHTML = state.filtered.map(templateCard).join('');
  }

  function applyFilters(){
    const raw = document.getElementById('q').value;
    const tags = state.activeTags;
    const { text, colorSet, usedColorOp, preferNameSort, bracketToken, pureDigit } = parseQuery(raw);

    let results = state.all.filter(d => {
      // bracket filter (operator or single-digit fallback)
      if (bracketToken){
        const b = String(d.bracket || '').toLowerCase();
        if (!b.includes(String(bracketToken).toLowerCase())) return false;
      } else if (pureDigit){
        const b = String(d.bracket || '');
        if (!b.includes(pureDigit)) return false;
      }

      // color filter
      if (!matchesColorFilter(d.colors, colorSet)) return false;

      // tags filter (all selected tags must be present)
      const deckTags = new Set(d.tags||[]);
      if (tags.size && ![...tags].every(t => deckTags.has(t))) return false;

      // text search (title, commander names, notes, tags)
      if (!text) return true;
      const hay = [
        d.title,
        (d._cmds||[]).map(x=>x.name).join(' / '),
        d.notes,
        (d.tags||[]).join(' ')
      ].join(' ').toLowerCase();
      return hay.includes(text.toLowerCase());
    });

    // sort:
    // - if query is pure color (no c:) or pure bracket (b: only or single digit), sort by title asc
    // - else default: updated desc, then title
    if (preferNameSort && !usedColorOp){
      results.sort((a,b)=> (a.title||'').localeCompare(b.title||'') || (a._idx-b._idx));
    } else {
      results.sort((a,b)=>{
        const ad = new Date(a.updated||0).getTime(), bd = new Date(b.updated||0).getTime();
        if (bd - ad) return bd - ad;
        return (a.title||'').localeCompare(b.title||'') || (a._idx-b._idx);
      });
    }

    state.filtered = results;
    render();
  }

  document.addEventListener('DOMContentLoaded', async () => {
    try{
      await loadDecks();
    }catch(e){ console.warn(e); }

    const q = document.getElementById('q');
    const clearBtn = document.getElementById('clearBtn');
    q.addEventListener('input', applyFilters);
    clearBtn.addEventListener('click', ()=>{ 
      q.value=''; state.activeTags.clear(); 
      document.querySelectorAll('.chip.active').forEach(c=>c.classList.remove('active')); 
      applyFilters(); 
    });
  });
  </script>

  <!-- Connection-aware background video loader -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      const isFast = !c || (c.effectiveType === '4g' && c.downlink >= 5 && !c.saveData);
      const isWifiLike = !c || (['wifi','ethernet'].includes(c.type || '') || typeof c.type === 'undefined');
      const allowVideo = isFast && isWifiLike;

      const wrap = document.getElementById('bgVideo');
      const vid  = document.getElementById('bgVideoEl');
      if (!wrap || !vid) return;

      if (!allowVideo) {
        wrap.style.display = 'none';
        return;
      }

      vid.src = '/assets/Blackhole_Animtation.mp4';

      const onReady = () => {
        wrap.classList.add('ready');
        const p = vid.play();
        if (p && typeof p.catch === 'function') p.catch(() => {});
      };

      vid.addEventListener('canplay', onReady, { once: true });
      vid.addEventListener('loadeddata', onReady, { once: true });
      vid.addEventListener('loadedmetadata', () => { wrap.classList.add('ready'); }, { once: true });
    });
  </script>

  <!-- === Partials injector (nav, discord, footer) === -->
  <script>
  (async () => {
    try {
      async function loadPartial(url) {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) return null;
        const html = await res.text();
        const tpl = document.createElement('template');
        tpl.innerHTML = html.trim();
        tpl.content.querySelectorAll('style').forEach(st => { document.head.appendChild(st.cloneNode(true)); st.remove(); });
        return tpl.content.firstElementChild || null;
      }
      const header = document.getElementById('site-header');
      const navEl = await loadPartial('/partials/nav.html');
      if (header && navEl) { header.innerHTML = ''; header.appendChild(navEl); initNav(header); }
      const discordEl = await loadPartial('/partials/discord.html');
      if (discordEl) document.body.appendChild(discordEl);
      const footerEl = await loadPartial('/partials/footer.html');
      if (footerEl) document.body.appendChild(footerEl);

      function initNav(scope) {
        const btn = scope.querySelector('.menu-toggle');
        const panel = scope.querySelector('#nav-panel');
        if (btn && panel) {
          btn.addEventListener('click', () => {
            const open = panel.classList.toggle('open');
            btn.setAttribute('aria-expanded', open ? 'true' : 'false');
          });
        }
        const here = location.pathname.toLowerCase().replace(/\/+$/, '');
        scope.querySelectorAll('.nav-link').forEach(a => {
          let href = (a.getAttribute('href') || '').toLowerCase().replace(/\/+$/, '');
          if (href === '/blog/') href = '/blog';
          if (here === href || ((here === '' || here === '/') && href === '/index.html')) a.setAttribute('aria-current', 'page');
          if (here.includes('/mtg')) a.setAttribute('aria-current', 'page'); // MTG highlight
          if (here.startsWith('/blog') && href === '/blog') a.setAttribute('aria-current', 'page');
        });
      }
    } catch (e) { console.warn('Partial load failed:', e); }
  })();
  </script>
</body>
</html>
